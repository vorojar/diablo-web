<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æš—é»‘ç ´åç¥ Webç‰ˆ (Hardcore Travel)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');

        :root {
            --bg-color: #050505;
            --ui-border: #4a3b2a;
            --text-gold: #c7b377;
            --text-red: #c23b22;
            --text-blue: #4d69cd;
            --item-unique: #908858;
            --item-rare: #ffff00;
            --item-magic: #4850b8;
            --item-normal: #ffffff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: #ccc;
            font-family: 'Cinzel', serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border: 2px solid var(--ui-border);
            background: rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            overflow: hidden;
            pointer-events: auto;
            z-index: 50;
        }

        #minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        #bottom-hud {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 140px;
            background: linear-gradient(to top, #111 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px 10px;
            box-sizing: border-box;
            pointer-events: auto;
        }

        .orb-container {
            width: 100px;
            height: 100px;
            position: relative;
            background: #222;
            border-radius: 50%;
            border: 4px solid #333;
            box-shadow: 0 0 20px #000 inset;
            overflow: hidden;
            z-index: 10;
        }

        .orb-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            transition: height 0.2s;
        }

        #health-orb .orb-fill {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #8a0e0e);
            box-shadow: 0 0 20px #ff0000;
        }

        #mana-orb .orb-fill {
            background: radial-gradient(circle at 30% 30%, #4d94ff, #0e2a8a);
            box-shadow: 0 0 20px #0055ff;
        }

        .orb-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 2;
        }

        #center-hud {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-bottom: 10px;
            gap: 5px;
            flex: 1;
            max-width: 600px;
        }

        .belt-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }

        .belt-slot {
            width: 36px;
            height: 36px;
            background: #111;
            border: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            font-size: 20px;
        }

        .belt-slot:hover {
            border-color: var(--text-gold);
        }

        .belt-key {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #888;
            background: #000;
            padding: 0 3px;
        }

        .belt-count {
            position: absolute;
            bottom: 0;
            right: 2px;
            font-size: 10px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        .xp-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .xp-bar {
            flex: 1;
            height: 8px;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: #c7b377;
            width: 0%;
            transition: width 0.2s;
        }

        .level-display {
            color: var(--text-gold);
            font-weight: bold;
            font-size: 14px;
            white-space: nowrap;
        }

        .skill-bar {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .skill-btn {
            width: 48px;
            height: 48px;
            background: #1a1a1a;
            border: 2px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: #888;
            cursor: pointer;
            position: relative;
        }

        .skill-btn.active {
            border-color: var(--text-gold);
            color: var(--text-gold);
        }

        .skill-btn .key {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: #fff;
        }

        .skill-btn .lvl {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: #aaa;
        }

        .panel {
            position: absolute;
            background: rgba(10, 10, 12, 0.95);
            border: 2px solid var(--ui-border);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
            padding: 15px;
            color: var(--text-gold);
            pointer-events: auto;
            display: none;
            width: 320px;
            z-index: 60;
        }

        .panel-header {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--ui-border);
            padding-bottom: 5px;
            cursor: move;
            user-select: none;
        }

        .panel-close {
            position: absolute;
            top: 5px;
            right: 10px;
            cursor: pointer;
            color: #888;
        }

        #stats-panel {
            top: 10%;
            left: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .stat-btn {
            background: #333;
            border: 1px solid #666;
            width: 20px;
            height: 20px;
            line-height: 18px;
            text-align: center;
            cursor: pointer;
            color: #fff;
        }

        .stat-btn:hover {
            background: #555;
        }

        #inventory-panel {
            top: 10%;
            right: 20px;
            width: 320px;
        }

        .equipment-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 20px;
            justify-items: center;
        }

        .equip-slot {
            width: 60px;
            height: 60px;
            border: 1px solid #444;
            background: #080808;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }

        .bag-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }

        .stash-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }

        .bag-slot {
            width: 48px;
            height: 48px;
            border: 1px solid #333;
            background: #080808;
            position: relative;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            color: #fff;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }

        #skills-panel {
            top: 15%;
            left: 340px;
            width: 280px;
        }

        .skill-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            border: 1px solid #333;
        }

        .skill-icon {
            width: 40px;
            height: 40px;
            background: #222;
            border: 1px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            margin-right: 10px;
        }

        .skill-info {
            flex: 1;
        }

        .skill-name {
            font-weight: bold;
            color: var(--text-gold);
            font-size: 0.9em;
        }

        .skill-desc {
            font-size: 0.7em;
            color: #888;
        }

        #shop-panel {
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
        }

        .gamble-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .gamble-slot {
            background: #111;
            border: 1px solid #444;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: background 0.2s;
        }

        .gamble-slot:hover {
            background: #222;
            border-color: var(--text-gold);
        }

        .gamble-price {
            color: gold;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .shop-section-title {
            text-align: center;
            color: #888;
            font-size: 12px;
            margin-top: 10px;
            margin-bottom: 5px;
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
        }

        #quest-panel {
            top: 15%;
            left: 20px;
            width: 300px;
        }

        #achievements-panel {
            top: 10%;
            left: 20px;
            width: 350px;
            max-height: 85%;
            overflow-y: auto;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        #achievements-panel::-webkit-scrollbar {
            width: 8px;
        }

        #achievements-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #achievements-panel::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
            border: 1px solid #666;
        }

        #achievements-panel::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Firefoxæ”¯æŒ */
        #achievements-panel {
            scrollbar-width: thin;
            scrollbar-color: #444 rgba(0, 0, 0, 0.3);
        }

        .achievement-item {
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #333;
            border-radius: 5px;
        }

        .achievement-item.completed {
            border-color: var(--text-gold);
            background: rgba(218, 165, 32, 0.1);
        }

        .achievement-item.completed::before {
            content: "âœ“ ";
            color: var(--text-gold);
            font-weight: bold;
            margin-right: 5px;
        }

        .ach-name {
            color: var(--text-gold);
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .ach-desc {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .ach-progress {
            color: #888;
            font-size: 11px;
            text-align: right;
        }

        .quest-item {
            border: 1px solid #444;
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.5);
        }

        .quest-title {
            color: var(--text-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .quest-status {
            font-size: 0.8em;
            color: #888;
        }

        .quest-status.completed {
            color: #00ff00;
        }

        #dialog-box {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--ui-border);
            padding: 20px;
            color: #ccc;
            display: none;
            z-index: 100;
            pointer-events: auto;
        }

        .dialog-name {
            color: var(--text-gold);
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .dialog-text {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .dialog-options {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .dialog-btn {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 5px 15px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
        }

        .dialog-btn:hover {
            border-color: var(--text-gold);
            color: var(--text-gold);
        }

        .drop-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border: 1px solid #333;
            font-size: 12px;
            cursor: pointer;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: auto;
        }

        .drop-label:hover {
            background: rgba(50, 50, 50, 0.9);
            border-color: #666;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--text-gold);
            padding: 10px;
            pointer-events: none;
            z-index: 100;
            display: none;
            max-width: 250px;
            font-size: 14px;
        }

        .tooltip-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-type {
            color: #888;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .tooltip-stat {
            color: #aaa;
            display: block;
        }

        #notification-area {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-gold);
            font-size: 16px;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
            transition: opacity 0.5s;
            opacity: 0;
            text-align: center;
        }

        #interaction-msg {
            position: absolute;
            top: 70%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
            display: none;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border: 1px solid #c7b377;
            border-radius: 4px;
            font-family: 'Cinzel', serif;
        }

        #floor-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #bbb;
            font-size: 1.4em;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }

        /* ä»»åŠ¡è¿½è¸ªå™¨ä½äºå·¦ä¾§ä¸‹æ–¹ */
        #quest-tracker {
            position: absolute;
            top: 60px;
            left: 20px;
            text-align: left;
            pointer-events: none;
            z-index: 10;
            max-width: 300px;
        }

        .tracker-title {
            color: #c7b377;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
        }

        .tracker-desc {
            color: #aaa;
            font-size: 12px;
            margin-top: 2px;
            text-shadow: 1px 1px 0 #000;
        }

        .menu-btns {
            position: absolute;
            bottom: 150px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: auto;
        }

        .sys-btn {
            background: #222;
            border: 1px solid #555;
            color: #aaa;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            position: relative;
        }

        .sys-btn:hover {
            border-color: var(--text-gold);
            color: var(--text-gold);
        }

        .notification-badge {
            position: absolute;
            top: -3px;
            right: -3px;
            width: 10px;
            height: 10px;
            background-color: #ff3333;
            border-radius: 50%;
            box-shadow: 0 0 4px #ff0000;
            display: none;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-image: radial-gradient(circle, #222 0%, #000 80%);
            pointer-events: auto;
        }

        h1 {
            color: #8a0e0e;
            font-size: 4em;
            margin-bottom: 0;
            text-shadow: 0 0 20px #ff0000;
            letter-spacing: 5px;
        }

        h2 {
            color: #555;
            margin-top: 0;
            font-size: 1.2em;
        }

        .start-btn {
            margin-top: 50px;
            padding: 15px 40px;
            background: #111;
            border: 2px solid #8a0e0e;
            color: #ccc;
            font-size: 1.5em;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: #8a0e0e;
            color: #000;
            box-shadow: 0 0 30px #8a0e0e;
        }

        .reset-btn {
            margin-top: 20px;
            padding: 8px 15px;
            background: #220000;
            border: 1px solid #500;
            color: #888;
            font-size: 0.9em;
            cursor: pointer;
            font-family: 'Cinzel', serif;
        }

        .reset-btn:hover {
            background: #400;
            color: #fff;
        }

        /* Settings */
        .settings-box {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }

        .setting-item {
            color: #888;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .setting-item:hover {
            color: #fff;
        }

        .setting-item input {
            cursor: pointer;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-layer">
            <div id="floor-display">ç½—æ ¼è¥åœ° (Town)</div>
            <div id="minimap-container"><canvas id="minimap" width="150" height="150"></canvas></div>
            <div id="quest-tracker"></div>
            <div id="world-labels"></div>
            <div id="interaction-msg"></div>
            <div id="notification-area"></div>

            <div id="start-screen">
                <h1>DIABLO</h1>
                <h2>ç»å…¸ç‰ˆ</h2>
                <button class="start-btn" onclick="startGame()">è¸å…¥åº‡æŠ¤æ‰€</button>
                <div class="settings-box">
                    <label class="setting-item"><input type="checkbox" id="chk-bgm" checked
                            onchange="toggleSetting('bgm')"> èƒŒæ™¯éŸ³ä¹</label>
                    <label class="setting-item"><input type="checkbox" id="chk-sfx" checked
                            onchange="toggleSetting('sfx')"> éŸ³æ•ˆ</label>
                </div>
                <button class="reset-btn" onclick="resetSave()">æ¸…é™¤å­˜æ¡£</button>
                <p style="color: #444; margin-top: 20px;">[C] è§’è‰² [I] ç‰©å“ [T] æŠ€èƒ½ [J] ä»»åŠ¡ [Alt] æ˜¾ç¤ºç‰©å“</p>
                <div id="save-status" style="color: #666; font-size: 12px; margin-top: 10px;">æ­£åœ¨æ£€æŸ¥å­˜æ¡£...</div>
            </div>

            <div id="stats-panel" class="panel">
                <div class="panel-close" onclick="togglePanel('stats')">X</div>
                <div class="panel-header">è§’è‰²å±æ€§</div>
                <div class="stat-row"><span>ç­‰çº§</span> <span id="stat-lvl" style="color:white">1</span></div>
                <div class="stat-row"><span>ç»éªŒ</span> <span id="stat-xp">0 / 100</span></div>
                <hr style="border-color: #333">
                <div class="stat-row" style="color:var(--text-gold)"><span>å±æ€§ç‚¹</span> <span id="stat-points">0</span>
                </div>
                <div class="stat-row"><span>åŠ›é‡</span>
                    <div><span id="stat-str">15</span> <button class="stat-btn" onclick="addStat('str')">+</button>
                    </div>
                </div>
                <div class="stat-row"><span>æ•æ·</span>
                    <div><span id="stat-dex">15</span> <button class="stat-btn" onclick="addStat('dex')">+</button>
                    </div>
                </div>
                <div class="stat-row"><span>ä½“åŠ›</span>
                    <div><span id="stat-vit">20</span> <button class="stat-btn" onclick="addStat('vit')">+</button>
                    </div>
                </div>
                <div class="stat-row"><span>ç²¾åŠ›</span>
                    <div><span id="stat-ene">10</span> <button class="stat-btn" onclick="addStat('ene')">+</button>
                    </div>
                </div>
                <hr style="border-color: #333">
                <div class="stat-row"><span>ç”Ÿå‘½å€¼ (HP)</span> <span id="stat-hp-val" style="color:#ff4444">100</span>
                </div>
                <div class="stat-row"><span>æ³•åŠ›å€¼ (MP)</span> <span id="stat-mp-val" style="color:#4444ff">50</span></div>
                <div class="stat-row"><span>ä¼¤å®³ (Dmg)</span> <span id="stat-dmg" style="color:white">2-4</span></div>
                <div class="stat-row"><span>æŠ¤ç”² (Def)</span> <span id="stat-def" style="color:white">5</span></div>
                <div class="stat-row"><span>æš´å‡»ç‡</span> <span id="stat-crit" style="color:#ffff00">0%</span></div>
                <div class="stat-row"><span>æ”»é€ŸåŠ æˆ</span> <span id="stat-ias" style="color:#ffff00">0%</span></div>
                <div class="stat-row"><span>ç”Ÿå‘½çªƒå–</span> <span id="stat-ll" style="color:#ff0000">0%</span></div>
            </div>

            <div id="inventory-panel" class="panel">
                <div class="panel-close" onclick="togglePanel('inventory')">X</div>
                <div class="panel-header">ç‰©å“æ </div>
                <div class="equipment-grid">
                    <!-- Row 1 -->
                    <div class="equip-slot" id="slot-helm" onclick="unequipItem('helm')"></div>
                    <div class="equip-slot" id="slot-amulet" onclick="unequipItem('amulet')"></div>
                    <div class="equip-slot" id="slot-body" onclick="unequipItem('body')"></div>
                    <!-- Row 2 -->
                    <div class="equip-slot" id="slot-mainhand" onclick="unequipItem('mainhand')"></div>
                    <div class="equip-slot" id="slot-offhand" onclick="unequipItem('offhand')"></div>
                    <div class="equip-slot" id="slot-gloves" onclick="unequipItem('gloves')"></div>
                    <!-- Row 3 -->
                    <div class="equip-slot" id="slot-ring" onclick="unequipItem('ring')"></div>
                    <div class="equip-slot" id="slot-belt" onclick="unequipItem('belt')"></div>
                    <div class="equip-slot" id="slot-boots" onclick="unequipItem('boots')"></div>
                </div>
                <div style="margin-bottom:5px; font-size: 0.8em; color: #888;">é‡‘å¸: <span id="gold-display"
                        style="color:gold">0</span> <span style="font-size:0.8em; color:#666;">(å•†åº—å¯å”®)</span></div>
                <div class="bag-grid" id="bag-grid"></div>
                <div
                    style="margin-top: 15px; padding: 8px; background: rgba(0, 0, 0, 0.5); border: 1px solid #333; border-radius: 5px; font-size: 11px; color: #aaa; line-height: 1.5;">
                    <div>ğŸ’¡ å·¦é”®ï¼šä½¿ç”¨æˆ–è£…å¤‡ç‰©å“ï¼ˆæ‰“å¼€ä»“åº“æ—¶å·¦é”®=å­˜å…¥ï¼‰ å³é”®ï¼šä¸¢å¼ƒç‰©å“ï¼ˆä»…åœ¨åœ°ç‰¢ï¼‰</div>
                    <div>ğŸ’° ç½—æ ¼è¥åœ°æ‰¾åŸºæ ¼å¯ä»¥ä¹°å–ç‰©å“ï¼Œæ‰¾ç“¦ç‘å¤«ä½¿ç”¨ä»“åº“</div>
                </div>
            </div>

            <div id="skills-panel" class="panel">
                <div class="panel-close" onclick="togglePanel('skills')">X</div>
                <div class="panel-header">æŠ€èƒ½æ ‘</div>
                <div style="text-align:center; color:var(--text-gold); margin-bottom:10px;">å‰©ä½™æŠ€èƒ½ç‚¹: <span
                        id="skill-points">0</span></div>
                <div class="skill-row">
                    <div class="skill-icon" style="color:#ff4400">ğŸ”¥</div>
                    <div class="skill-info">
                        <div class="skill-name">ç«çƒæœ¯ [Q]</div>
                        <div class="skill-desc">å‘å°„ç«çƒ (å°„ç¨‹: ä¸­ç­‰)</div>
                    </div>
                    <div style="font-size:12px; color:#fff">Lv <span id="lvl-fireball">1</span> <button class="stat-btn"
                            onclick="upgradeSkill('fireball')">+</button></div>
                </div>
                <div class="skill-row">
                    <div class="skill-icon" style="color:#00ccff">â„ï¸</div>
                    <div class="skill-info">
                        <div class="skill-name">å†°éœœæ–°æ˜Ÿ [W]</div>
                        <div class="skill-desc">å†»ç»“æ•Œäºº (å°„ç¨‹: çŸ­ç¨‹èŒƒå›´)</div>
                    </div>
                    <div style="font-size:12px; color:#fff">Lv <span id="lvl-frostnova">0</span> <button
                            class="stat-btn" onclick="upgradeSkill('frostnova')">+</button></div>
                </div>
                <div class="skill-row">
                    <div class="skill-icon" style="color:#ffff00">ğŸ¹</div>
                    <div class="skill-info">
                        <div class="skill-name">å¤šé‡å°„å‡» [E]</div>
                        <div class="skill-desc">æ‰‡å½¢ç®­çŸ¢</div>
                    </div>
                    <div style="font-size:12px; color:#fff">Lv <span id="lvl-multishot">0</span> <button
                            class="stat-btn" onclick="upgradeSkill('multishot')">+</button></div>
                </div>
            </div>

            <div id="quest-panel" class="panel">
                <div class="panel-close" onclick="togglePanel('quest')">X</div>
                <div class="panel-header">ä»»åŠ¡æ—¥å¿—</div>
                <div id="quest-list"></div>
            </div>

            <div id="achievements-panel" class="panel">
                <div class="panel-close" onclick="togglePanel('achievements')">X</div>
                <div class="panel-header">æˆå°±</div>
                <div id="achievement-list"></div>
            </div>

            <div id="shop-panel" class="panel">
                <div class="panel-close" onclick="togglePanel('shop')">X</div>
                <div class="panel-header">åŸºæ ¼å•†åº—</div>
                <div class="shop-section-title">ç‰©èµ„è¡¥ç»™</div>
                <div class="gamble-grid" style="margin-top:0;">
                    <div class="gamble-slot" onclick="buyItem('health')">
                        <div style="font-size:24px">ğŸ”´</div>
                        <div>æ²»ç–—è¯å‰‚</div>
                        <div class="gamble-price">50 G</div>
                    </div>
                    <div class="gamble-slot" onclick="buyItem('mana')">
                        <div style="font-size:24px; color:#4d94ff">ğŸ”µ</div>
                        <div>æ³•åŠ›è¯å‰‚</div>
                        <div class="gamble-price">50 G</div>
                    </div>
                    <div class="gamble-slot" onclick="buyItem('scroll')">
                        <div style="font-size:24px">ğŸ“œ</div>
                        <div>å›åŸå·è½´</div>
                        <div class="gamble-price">100 G</div>
                    </div>
                </div>
                <div class="shop-section-title" style="margin-top:15px;">æœªè¾¨è¯†è£…å¤‡ (èµŒåš)</div>
                <div class="gamble-grid" style="margin-top:0; grid-template-columns: repeat(4, 1fr);">
                    <div class="gamble-slot" onclick="gambleItem('weapon')">
                        <div style="font-size:24px">ğŸ—¡ï¸</div>
                        <div>æ­¦å™¨</div>
                        <div class="gamble-price">500</div>
                    </div>
                    <div class="gamble-slot" onclick="gambleItem('armor')">
                        <div style="font-size:24px">ğŸ‘•</div>
                        <div>æŠ¤ç”²</div>
                        <div class="gamble-price">400</div>
                    </div>
                    <div class="gamble-slot" onclick="gambleItem('helm')">
                        <div style="font-size:24px">ğŸª–</div>
                        <div>å¤´ç›”</div>
                        <div class="gamble-price">300</div>
                    </div>
                    <div class="gamble-slot" onclick="gambleItem('gloves')">
                        <div style="font-size:24px">ğŸ§¤</div>
                        <div>æ‰‹å¥—</div>
                        <div class="gamble-price">250</div>
                    </div>
                    <div class="gamble-slot" onclick="gambleItem('boots')">
                        <div style="font-size:24px">ğŸ‘¢</div>
                        <div>é‹å­</div>
                        <div class="gamble-price">250</div>
                    </div>
                    <div class="gamble-slot" onclick="gambleItem('belt')">
                        <div style="font-size:24px">ğŸ—ï¸</div>
                        <div>è…°å¸¦</div>
                        <div class="gamble-price">250</div>
                    </div>
                    <div class="gamble-slot" onclick="gambleItem('ring')">
                        <div style="font-size:24px">ğŸ’</div>
                        <div>æˆ’æŒ‡</div>
                        <div class="gamble-price">800</div>
                    </div>
                    <div class="gamble-slot" onclick="gambleItem('amulet')">
                        <div style="font-size:24px">ğŸ“¿</div>
                        <div>é¡¹é“¾</div>
                        <div class="gamble-price">1000</div>
                    </div>
                </div>
                <div
                    style="margin-top: 20px; padding: 10px; background: rgba(0, 0, 0, 0.5); border: 1px solid #333; border-radius: 5px; font-size: 12px; color: #aaa; text-align: center;">
                    ğŸ’¡ æç¤ºï¼šç‚¹å‡»èƒŒåŒ…ä¸­çš„ç‰©å“å¯ä»¥å–ç»™æˆ‘æ¢é‡‘å¸ï¼
                </div>
            </div>

            <div id="stash-panel" class="panel">
                <div class="panel-close" onclick="togglePanel('stash')">X</div>
                <div class="panel-header">ç§äººä»“åº“</div>
                <div style="margin-bottom:10px; font-size: 0.9em; color: #888;">ä¸èƒŒåŒ…äº’é€šï¼Œå¯è‡ªç”±å­˜å–ç‰©å“</div>
                <div class="stash-grid" id="stash-grid"></div>
                <div
                    style="margin-top: 15px; padding: 8px; background: rgba(0, 0, 0, 0.5); border: 1px solid #333; border-radius: 5px; font-size: 11px; color: #aaa;">
                    ğŸ’¡ æç¤ºï¼šå·¦é”®ç‚¹å‡»èƒŒåŒ…ç‰©å“å­˜å…¥ä»“åº“ï¼Œå·¦é”®ç‚¹å‡»ä»“åº“ç‰©å“å–å‡ºåˆ°èƒŒåŒ…
                </div>
            </div>

            <div id="dialog-box">
                <div class="dialog-name" id="dialog-name">NPC Name</div>
                <div class="dialog-text" id="dialog-text">Hello adventurer.</div>
                <div class="dialog-options" id="dialog-options"><button class="dialog-btn"
                        onclick="closeDialog()">ç¦»å¼€</button></div>
            </div>

            <div class="menu-btns" id="menu-btns">
                <button class="sys-btn" id="btn-stats" onclick="togglePanel('stats')">è§’è‰² (C)<span
                        class="notification-badge" id="badge-stats"></span></button>
                <button class="sys-btn" id="btn-inventory" onclick="togglePanel('inventory')">ç‰©å“ (I)</button>
                <button class="sys-btn" id="btn-skills" onclick="togglePanel('skills')">æŠ€èƒ½ (T)<span
                        class="notification-badge" id="badge-skills"></span></button>
                <button class="sys-btn" id="btn-quest" onclick="togglePanel('quest')">ä»»åŠ¡ (J)<span
                        class="notification-badge" id="badge-quest"></span></button>
                <button class="sys-btn" id="btn-achievements" onclick="togglePanel('achievements')">æˆå°± (A)</button>
            </div>

            <div id="bottom-hud">
                <div class="orb-container" id="health-orb">
                    <div class="orb-fill" id="hp-fill" style="height: 100%"></div>
                    <div class="orb-text" id="hp-text">100</div>
                </div>
                <div id="center-hud">
                    <div class="belt-bar" id="belt-bar">
                        <div class="belt-slot" onclick="useQuickItem('health')" id="belt-1"><span
                                class="belt-key">1</span> ğŸ”´ <span class="belt-count" id="count-health">0</span></div>
                        <div class="belt-slot" onclick="useQuickItem('mana')" id="belt-2"><span
                                class="belt-key">2</span> ğŸ”µ <span class="belt-count" id="count-mana"
                                style="color:#4d94ff">0</span></div>
                        <div class="belt-slot" onclick="useQuickItem('scroll')" id="belt-3"><span
                                class="belt-key">3</span> ğŸ“œ <span class="belt-count" id="count-scroll">0</span></div>
                    </div>
                    <div class="xp-container">
                        <div class="xp-bar">
                            <div class="xp-fill" id="xp-fill"></div>
                        </div>
                        <div class="level-display">Lv. <span id="hud-lvl">1</span></div>
                    </div>
                    <div class="skill-bar">
                        <div class="skill-btn active" id="skill-attack" onclick="selectSkill('attack')"><span
                                class="key">LMB</span> âš”ï¸</div>
                        <div class="skill-btn" onclick="selectSkill('fireball')"><span class="key">Q</span> ğŸ”¥ <span
                                class="lvl" id="bar-lvl-fireball">1</span></div>
                        <div class="skill-btn" onclick="selectSkill('frostnova')"><span class="key">W</span> â„ï¸ <span
                                class="lvl" id="bar-lvl-frostnova">0</span></div>
                        <div class="skill-btn" onclick="selectSkill('multishot')"><span class="key">E</span> ğŸ¹ <span
                                class="lvl" id="bar-lvl-multishot">0</span></div>
                    </div>
                </div>
                <div class="orb-container" id="mana-orb">
                    <div class="orb-fill" id="mp-fill" style="height: 100%"></div>
                    <div class="orb-text" id="mp-text">50</div>
                </div>
            </div>
            <div id="tooltip"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const miniCanvas = document.getElementById('minimap');
        const miniCtx = miniCanvas.getContext('2d');

        const TILE_SIZE = 40;
        const MAP_WIDTH = 64;
        const MAP_HEIGHT = 64;

        const COLORS = {
            white: '#ffffff', blue: '#4850b8', yellow: '#ffff00', gold: '#908858', red: '#c23b22', green: '#00ff00',
            ice: '#00ccff', floor: '#0c0c0c', floorAlt: '#080808', wall: '#2C2C2C', townFloor: '#1a1a1a',
            exit: '#0055aa', entrance: '#aa5500'
        };

        let gameActive = false;
        let lastTime = 0;
        let particles = [];
        let damageNumbers = [];
        let enemies = [];
        let groundItems = [];
        let projectiles = [];
        let npcs = [];
        let autoSaveTimer = 0;
        let isAltPressed = false;

        let mapData = [];
        let visitedMap = [];
        let dungeonExit = { x: 0, y: 0 };
        let dungeonEntrance = { x: 0, y: 0 };
        let townPortal = null;
        let interactionTarget = null;

        const mouse = { x: 0, y: 0, worldX: 0, worldY: 0, leftDown: false, rightDown: false };
        const camera = { x: 0, y: 0 };

        // Settings
        const Settings = { bgm: true, sfx: true };

        const QUEST_DB = [
            { id: 0, title: 'é‚ªæ¶æ´çªŸ', desc: 'æ¸…é™¤åœ°ç‰¢ç¬¬1å±‚çš„ 10 åªæ€ªç‰©ã€‚', type: 'kill_count', target: 10, floor: 1, reward: '1 æŠ€èƒ½ç‚¹' },
            { id: 1, title: 'åŸ‹éª¨ä¹‹åœ°', desc: 'åœ¨åœ°ç‰¢ç¬¬2å±‚å‡»æ€ç²¾è‹±æ€ª"è¡€é¸Ÿ"ã€‚', type: 'kill_elite', targetName: 'è¡€é¸Ÿ', floor: 2, reward: 'ç¨€æœ‰æˆ’æŒ‡' },
            { id: 2, title: 'é»‘è‰²è’åœ°', desc: 'åœ¨åœ°ç‰¢ç¬¬3å±‚å‡»æ€ 15 åªæ€ªç‰©ã€‚', type: 'kill_count', target: 15, floor: 3, reward: '500 é‡‘å¸' },
            { id: 3, title: 'é—å¿˜ä¹‹å¡”', desc: 'åœ¨åœ°ç‰¢ç¬¬4å±‚å‡»æ€"å¥³ä¼¯çˆµ"ã€‚', type: 'kill_elite', targetName: 'å¥³ä¼¯çˆµ', floor: 4, reward: 'éšæœºç¬¦æ–‡' },
            { id: 4, title: 'å± å¤«çš„æœ«æ—¥', desc: 'åœ¨åœ°ç‰¢ç¬¬5å±‚å‡»æ€å± å¤«ã€‚', type: 'kill_boss', targetName: 'å± å¤«', floor: 5, reward: 'æš—é‡‘è£…å¤‡' },
            { id: 5, title: 'èœ˜è››æ£®æ—', desc: 'æ¸…é™¤åœ°ç‰¢ç¬¬6å±‚çš„ 20 åªæ€ªç‰©ã€‚', type: 'kill_count', target: 20, floor: 6, reward: '2 æŠ€èƒ½ç‚¹' },
            { id: 6, title: 'å‰¥çš®ä¸›æ—', desc: 'åœ¨åœ°ç‰¢ç¬¬7å±‚å‡»æ€ç²¾è‹±æ€ª"æ ‘å¤´æœ¨æ‹³"ã€‚', type: 'kill_elite', targetName: 'æ ‘å¤´æœ¨æ‹³', floor: 7, reward: 'æš—é‡‘é¥°å“' },
            { id: 7, title: 'æ†æ¨å›šç‰¢', desc: 'åœ¨åœ°ç‰¢ç¬¬8å±‚å‡»æ€ 25 åªæ€ªç‰©ã€‚', type: 'kill_count', target: 25, floor: 8, reward: '1000 é‡‘å¸' },
            { id: 8, title: 'æ··æ²Œé¿éš¾æ‰€', desc: 'åœ¨åœ°ç‰¢ç¬¬9å±‚å‡»æ€"æš—é»‘ç ´åç¥"ã€‚', type: 'kill_elite', targetName: 'æš—é»‘ç ´åç¥', floor: 9, reward: 'ä¼ å¥‡è£…å¤‡' },
            { id: 9, title: 'ä¸–ç•Œä¹‹çŸ³è¦å¡', desc: 'åœ¨åœ°ç‰¢ç¬¬10å±‚å‡»è´¥å·´å°”ï¼Œæ‹¯æ•‘ä¸–ç•Œã€‚', type: 'kill_boss', targetName: 'å·´å°”', floor: 10, reward: 'ç»ˆæç¥è£…' }
        ];

        const MONSTER_FRAMES = {
            'melee': 0,
            'ranged': 1,
            'shaman': 2,
            'elite': 3,
            'boss': 3
        };

        const player = {
            x: 0, y: 0, radius: 12, color: '#eee', speed: 180, direction: 'front',
            lvl: 1, xp: 0, xpNext: 100, points: 0, skillPoints: 1,
            str: 15, dex: 15, vit: 20, ene: 10,
            floor: 0,
            hp: 100, maxHp: 100, mp: 50, maxMp: 50, damage: [2, 4], armor: 5, gold: 0,
            lifeSteal: 0, attackSpeed: 0, critChance: 0,
            skills: { fireball: 1, frostnova: 0, multishot: 0 }, activeSkill: 'fireball',
            targetX: null, targetY: null, attacking: false, attackCooldown: 0,
            skillCooldowns: { fireball: 0, frostnova: 0, multishot: 0 },
            equipment: {
                mainhand: null, offhand: null, body: null, ring: null,
                helm: null, gloves: null, boots: null, belt: null, amulet: null
            },
            inventory: Array(30).fill(null),
            stash: Array(36).fill(null), // ä»“åº“ï¼Œ36ä¸ªæ ¼å­
            questIndex: 0, questState: 0, questProgress: 0,
            portalTimer: 0,
            died: false,
            achievements: {}
        };

        const spriteSheet = new Image();
        spriteSheet.src = 'sprites.png';

        let spritesLoaded = false;
        let processedSpriteSheet = null;

        spriteSheet.onload = () => {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = spriteSheet.width;
            tempCanvas.height = spriteSheet.height;

            tempCtx.drawImage(spriteSheet, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                if (r > 240 && g > 240 && b > 240) {
                    data[i + 3] = 0;
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            processedSpriteSheet = new Image();
            processedSpriteSheet.onload = () => { spritesLoaded = true; };
            processedSpriteSheet.src = tempCanvas.toDataURL();
        };

        const SPRITE_CONFIG = {
            frameWidth: 256,
            frameHeight: 341,
            heroRow: 0,
            monsterRow: 1,
            npcRow: 2
        };

        // æˆå°±ç³»ç»Ÿå®šä¹‰
        const ACHIEVEMENTS = [
            {
                id: 'kill_fallen_1000',
                name: 'æ²‰æ²¦é­”å…‹æ˜Ÿ',
                description: 'å‡»æ€1000åªæ²‰æ²¦é­”',
                target: 1000,
                type: 'kill_monster',
                monsterName: 'æ²‰æ²¦é­”'
            },
            {
                id: 'reach_floor_10',
                name: 'åœ°ç‰¢å¾æœè€…',
                description: 'åˆ°è¾¾åœ°ç‰¢ç¬¬10å±‚',
                target: 10,
                type: 'reach_floor'
            },
            {
                id: 'all_unique_equipment',
                name: 'æš—é‡‘æ”¶è—å®¶',
                description: 'æ”¶é›†å…¨å¥—æš—é‡‘è£…å¤‡',
                target: 1,
                type: 'collect_unique_set'
            },
            {
                id: 'no_death_floor10',
                name: 'é’¢é“æ„å¿—',
                description: 'ä»æœªæ­»äº¡åˆ°è¾¾ç¬¬10å±‚',
                target: 10,
                type: 'no_death_floor'
            },
            {
                id: 'kill_boss_5',
                name: 'BOSSçŒäºº',
                description: 'å‡»è´¥5ä¸ªé¦–é¢†çº§æ•Œäºº',
                target: 5,
                type: 'kill_boss'
            },
            {
                id: 'reach_level_30',
                name: 'ä¼ å¥‡è‹±é›„',
                description: 'è¾¾åˆ°ç­‰çº§30',
                target: 30,
                type: 'reach_level'
            }
        ];

        function getHeroFrame(direction) {
            const frameMap = {
                'left': 0,
                'right': 1,
                'front': 2,
                'back': 3
            };
            const frameX = (frameMap[direction] || 0) * SPRITE_CONFIG.frameWidth;
            const frameY = SPRITE_CONFIG.heroRow * SPRITE_CONFIG.frameHeight;
            return {
                x: frameX,
                y: frameY,
                width: SPRITE_CONFIG.frameWidth,
                height: SPRITE_CONFIG.frameHeight
            };
        }

        function getNPCFrame(frameIndex) {
            const frameX = frameIndex * SPRITE_CONFIG.frameWidth;
            const frameY = SPRITE_CONFIG.npcRow * SPRITE_CONFIG.frameHeight;
            return {
                x: frameX,
                y: frameY,
                width: SPRITE_CONFIG.frameWidth,
                height: SPRITE_CONFIG.frameHeight
            };
        }

        function getMonsterFrame(frameIndex) {
            const frameX = frameIndex * SPRITE_CONFIG.frameWidth;
            const frameY = SPRITE_CONFIG.monsterRow * SPRITE_CONFIG.frameHeight;
            return {
                x: frameX,
                y: frameY,
                width: SPRITE_CONFIG.frameWidth,
                height: SPRITE_CONFIG.frameHeight
            };
        }

        // æˆå°±è¿½è¸ªç³»ç»Ÿ
        function trackAchievement(type, data) {
            ACHIEVEMENTS.forEach(ach => {
                if (ach.type !== type || !player.achievements[ach.id]) return;

                if (player.achievements[ach.id].completed) return;

                let progress = 0;

                switch (type) {
                    case 'kill_monster':
                        if (data.monsterName === ach.monsterName) {
                            player.achievements[ach.id].progress++;
                            progress = player.achievements[ach.id].progress;
                        }
                        break;

                    case 'reach_floor':
                        if (player.floor >= ach.target) {
                            completeAchievement(ach);
                        }
                        return;

                    case 'collect_unique_set':
                        checkAllUniqueEquipment();
                        return;

                    case 'no_death_floor':
                        if (player.floor >= ach.target && !player.died) {
                            completeAchievement(ach);
                        }
                        return;

                    case 'kill_boss':
                        if (data.isBoss || data.isQuestTarget) {
                            player.achievements[ach.id].progress++;
                            progress = player.achievements[ach.id].progress;
                        }
                        break;

                    case 'reach_level':
                        if (player.lvl >= ach.target) {
                            completeAchievement(ach);
                        }
                        return;
                }

                if (progress >= ach.target) {
                    completeAchievement(ach);
                }
            });
        }

        function completeAchievement(achievement) {
            player.achievements[achievement.id].completed = true;
            player.achievements[achievement.id].completedAt = Date.now();

            showNotification(`æˆå°±å®Œæˆï¼š${achievement.name}ï¼`);
            AudioSys.play('quest');

            saveGame();
        }

        function checkAllUniqueEquipment() {
            const uniqueItems = [];
            Object.values(player.equipment).forEach(item => {
                if (item && item.unique) uniqueItems.push(item);
            });

            const ach = ACHIEVEMENTS.find(a => a.id === 'all_unique_equipment');
            if (!ach || !player.achievements['all_unique_equipment']) return;

            if (uniqueItems.length >= 8 && !player.achievements['all_unique_equipment'].completed) {
                completeAchievement(ach);
            }
        }

        function checkNoDeathRun() {
            if (player.floor >= 10) {
                const ach = ACHIEVEMENTS.find(a => a.id === 'no_death_run');
                if (!ach || !player.achievements['no_death_run']) return;

                if (!player.achievements['no_death_run'].completed) {
                    completeAchievement(ach);
                }
            }
        }

        function initAchievements() {
            ACHIEVEMENTS.forEach(ach => {
                if (!player.achievements[ach.id]) {
                    player.achievements[ach.id] = {
                        progress: 0,
                        completed: false
                    };
                }
            });
        }

        const SLOT_MAP = {
            'weapon': 'mainhand', 'armor': 'body', 'helm': 'helm', 'gloves': 'gloves',
            'boots': 'boots', 'belt': 'belt', 'ring': 'ring', 'amulet': 'amulet'
        };

        const DB_NAME = 'DiabloCloneDB'; const DB_VERSION = 8; let db;

        const AudioSys = {
            ctx: null,
            bgmEl: null,
            bgmUrl: "bg.mp3",
            masterGain: null, sfxGain: null,
            bgmPlaying: false,
            bgmRetryNeeded: false,
            init: function () {
                if (!this.ctx && (window.AudioContext || window.webkitAudioContext)) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.sfxGain = this.ctx.createGain();

                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.ctx.destination);

                    this.sfxGain.gain.value = Settings.sfx ? 1.0 : 0;

                    this.bgmEl = new Audio(this.bgmUrl);
                    this.bgmEl.loop = true;
                    this.bgmEl.volume = Settings.bgm ? 0.3 : 0;

                    // ç›‘å¬éŸ³é¢‘ç»“æŸäº‹ä»¶ï¼Œç¡®ä¿å¾ªç¯æ’­æ”¾
                    this.bgmEl.addEventListener('ended', () => {
                        if (Settings.bgm && this.bgmPlaying) {
                            this.bgmEl.currentTime = 0;
                            this.bgmEl.play().catch(e => console.log("BGM restart failed:", e));
                        }
                    });
                }
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },
            startBGM: function () {
                if (this.bgmEl && Settings.bgm && !this.bgmPlaying) {
                    console.log("Attempting to start BGM...");
                    this.bgmPlaying = true;
                    this.bgmEl.play().then(() => {
                        console.log("âœ… BGM started successfully");
                    }).catch(e => {
                        console.log("âŒ BGM play failed:", e);
                        this.bgmPlaying = false;
                        // å¦‚æœå¤±è´¥ï¼Œå¯èƒ½æ˜¯éœ€è¦æ›´å¤šç”¨æˆ·äº¤äº’ï¼Œè®¾ç½®æ ‡è®°ç¨åé‡è¯•
                        this.bgmRetryNeeded = true;
                    });
                }
            },
            stopBGM: function () {
                if (this.bgmEl && this.bgmPlaying) {
                    this.bgmEl.pause();
                    this.bgmPlaying = false;
                }
            },
            resumeBGM: function () {
                if (this.bgmEl && Settings.bgm && !this.bgmPlaying) {
                    // å¦‚æœæœ‰é‡è¯•æ ‡è®°ï¼Œå…ˆå°è¯•startBGM
                    if (this.bgmRetryNeeded) {
                        this.bgmRetryNeeded = false;
                        this.startBGM();
                    } else {
                        this.bgmEl.play().then(() => {
                            this.bgmPlaying = true;
                            console.log("âœ… BGM resumed successfully");
                        }).catch(e => {
                            console.log("âŒ BGM resume failed:", e);
                            this.bgmPlaying = false;
                        });
                    }
                }
            },
            // åœ¨ä»»ä½•ç”¨æˆ·äº¤äº’æ—¶è°ƒç”¨ï¼Œå°è¯•å¯åŠ¨BGM
            tryAutoStartBGM: function () {
                if (this.bgmRetryNeeded && Settings.bgm) {
                    console.log("ğŸ”„ Auto-retrying BGM start...");
                    this.bgmRetryNeeded = false;
                    this.startBGM();
                }
            },
            play: function (type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.sfxGain);

                if (type === 'gold') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(1800, t);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    osc.start(); osc.stop(t + 0.3);
                } else if (type === 'attack') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.1);
                    osc.start(); osc.stop(t + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, t);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                    osc.start(); osc.stop(t + 0.1);
                } else if (type === 'quest') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(440, t);
                    osc.frequency.setValueAtTime(554, t + 0.2); osc.frequency.setValueAtTime(659, t + 0.4);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.setValueAtTime(0, t + 1);
                    osc.start(); osc.stop(t + 1);
                } else if (type === 'levelup') {
                    [440, 554, 659, 880].forEach((f, i) => {
                        let o = this.ctx.createOscillator(); let g = this.ctx.createGain();
                        o.connect(g); g.connect(this.sfxGain);
                        o.frequency.value = f;
                        g.gain.setValueAtTime(0.1, t + i * 0.1); g.gain.linearRampToValueAtTime(0, t + i * 0.1 + 0.3);
                        o.start(t + i * 0.1); o.stop(t + i * 0.1 + 0.3);
                    });
                } else if (type === 'potion') {
                    // å’•å™œå™œçš„å–è¯éŸ³æ•ˆ - ä½¿ç”¨å¤šä¸ªæŒ¯è¡å™¨æ¨¡æ‹Ÿæ¶²ä½“æµåŠ¨å£°
                    [200, 250, 300].forEach((f, i) => {
                        let o = this.ctx.createOscillator();
                        let g = this.ctx.createGain();
                        o.type = 'sine';
                        o.connect(g);
                        g.connect(this.sfxGain);
                        o.frequency.setValueAtTime(f, t + i * 0.05);
                        o.frequency.exponentialRampToValueAtTime(f * 0.5, t + i * 0.05 + 0.2);
                        g.gain.setValueAtTime(0.08, t + i * 0.05);
                        g.gain.exponentialRampToValueAtTime(0.01, t + i * 0.05 + 0.3);
                        o.start(t + i * 0.05);
                        o.stop(t + i * 0.05 + 0.3);
                    });
                } else if (type === 'fireball') {
                    // é€¼çœŸçš„ç«çƒéŸ³æ•ˆ - ä¸‰å±‚å åŠ ï¼šçˆ†å‘å†²å‡» + ç«ç„°ç‡ƒçƒ§ + ç©ºæ°”æŒ¯åŠ¨

                    // 1. çˆ†å‘å†²å‡»å±‚ - æ–¹æ³¢æ¨¡æ‹Ÿçˆ†ç‚¸å†²å‡»
                    const osc1 = this.ctx.createOscillator();
                    const gain1 = this.ctx.createGain();
                    osc1.type = 'square';
                    osc1.connect(gain1);
                    gain1.connect(this.sfxGain);
                    osc1.frequency.setValueAtTime(80, t);
                    osc1.frequency.exponentialRampToValueAtTime(40, t + 0.2);
                    gain1.gain.setValueAtTime(0.3, t);
                    gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                    osc1.start(t);
                    osc1.stop(t + 0.3);

                    // 2. ç«ç„°ç‡ƒçƒ§å±‚ - é”¯é½¿æ³¢æ¨¡æ‹Ÿç«ç„°å™¼å•ªå£°
                    [120, 150, 180].forEach((f, i) => {
                        const osc2 = this.ctx.createOscillator();
                        const gain2 = this.ctx.createGain();
                        osc2.type = 'sawtooth';
                        osc2.connect(gain2);
                        gain2.connect(this.sfxGain);
                        osc2.frequency.setValueAtTime(f, t + i * 0.03);
                        osc2.frequency.exponentialRampToValueAtTime(f * 0.3, t + 0.4);
                        gain2.gain.setValueAtTime(0.1 - i * 0.02, t + i * 0.03);
                        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                        osc2.start(t + i * 0.03);
                        osc2.stop(t + 0.5);
                    });
                    // 3. é«˜é¢‘å˜¶å˜¶å£°å±‚ - æ­£å¼¦æ³¢æ¨¡æ‹Ÿç©ºæ°”æŒ¯åŠ¨
                    const osc3 = this.ctx.createOscillator();
                    const gain3 = this.ctx.createGain();
                    osc3.type = 'sine';
                    osc3.connect(gain3);
                    gain3.connect(this.sfxGain);
                    osc3.frequency.setValueAtTime(1000, t);
                    osc3.frequency.exponentialRampToValueAtTime(500, t + 0.15);
                    gain3.gain.setValueAtTime(0.05, t);
                    gain3.gain.linearRampToValueAtTime(0, t + 0.2);
                    osc3.start(t);
                    osc3.stop(t + 0.2);
                } else if (type === 'arrow') {
                    // ç®­çŸ¢éŸ³æ•ˆ - é£å£°å’Œæ’å‡»å£°
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'triangle';
                    osc.connect(gain);
                    gain.connect(this.sfxGain);
                    osc.frequency.setValueAtTime(800, t);
                    osc.frequency.exponentialRampToValueAtTime(400, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc.start(t);
                    osc.stop(t + 0.2);
                }
            },
            toggleSetting: function (key, val) {
                Settings[key] = val;
                if (key === 'bgm' && this.bgmEl) {
                    this.bgmEl.volume = val ? 0.3 : 0;
                    if (val && !this.bgmPlaying) {
                        // å¦‚æœå¼€å¯BGMä¸”å½“å‰æ²¡æœ‰æ’­æ”¾ï¼Œå°è¯•æ’­æ”¾
                        this.startBGM();
                    } else if (!val && this.bgmPlaying) {
                        // å¦‚æœå…³é—­BGMä¸”å½“å‰æ­£åœ¨æ’­æ”¾ï¼Œæš‚åœæ’­æ”¾
                        this.stopBGM();
                    }
                }
                if (key === 'sfx' && this.sfxGain) {
                    this.sfxGain.gain.setValueAtTime(val ? 1.0 : 0, this.ctx.currentTime);
                }
            }
        };

        const SaveSystem = {
            init: function () {
                const req = indexedDB.open(DB_NAME, DB_VERSION);
                req.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('saveData')) db.createObjectStore('saveData', { keyPath: 'id' });
                };
                req.onsuccess = e => { db = e.target.result; this.load(); };
                req.onerror = e => { console.error("DB Init Failed", e); };
            },
            save: function () {
                if (!db) return;
                const clean = i => { if (!i) return null; const { el, ...r } = i; return r; };
                const eq = {}; for (let k in player.equipment) eq[k] = clean(player.equipment[k]);
                const data = {
                    id: 'player1', ...player,
                    inventory: player.inventory.map(clean),
                    equipment: eq,
                    stash: player.stash.map(clean), // ä¿å­˜ä»“åº“
                    townPortal: townPortal,
                    settings: Settings // Save settings
                };
                db.transaction(['saveData'], 'readwrite').objectStore('saveData').put(data);
                showNotification("æ¸¸æˆå·²ä¿å­˜");
            },
            load: function () {
                if (!db) return;
                db.transaction(['saveData']).objectStore('saveData').get('player1').onsuccess = e => {
                    if (e.target.result) {
                        window.pendingLoadData = e.target.result;
                        const f = e.target.result.floor === 0 ? "ç½—æ ¼è¥åœ°" : `åœ°ç‰¢ ${e.target.result.floor}å±‚`;
                        document.getElementById('save-status').innerText = `å‘ç°å­˜æ¡£: Lv${e.target.result.lvl} - ${f}`;

                        // Load Settings
                        if (e.target.result.settings) {
                            Object.assign(Settings, e.target.result.settings);
                            document.getElementById('chk-bgm').checked = Settings.bgm;
                            document.getElementById('chk-sfx').checked = Settings.sfx;
                        }
                    }
                };
            },
            reset: function () { if (db) db.transaction(['saveData'], 'readwrite').objectStore('saveData').delete('player1'); location.reload(); }
        };

        const ITEM_TYPES = {
            WEAPON: { icon: 'âš”ï¸' }, ARMOR: { icon: 'ğŸ›¡ï¸' }, RING: { icon: 'ğŸ’' }, POTION: { icon: 'ğŸ·' }, SCROLL: { icon: 'ğŸ“œ' },
            HELM: { icon: 'ğŸª–' }, GLOVES: { icon: 'ğŸ§¤' }, BOOTS: { icon: 'ğŸ‘¢' }, BELT: { icon: 'ğŸ—ï¸' }, AMULET: { icon: 'ğŸ“¿' }
        };

        const BASE_ITEMS = [
            { name: 'çŸ­å‰‘', type: 'weapon', minDmg: 2, maxDmg: 5, rarity: 1, icon: 'ğŸ—¡ï¸' },
            { name: 'å·¨æ–§', type: 'weapon', minDmg: 6, maxDmg: 14, rarity: 1, icon: 'ğŸª“' },
            { name: 'å¸ƒç”²', type: 'armor', def: 5, rarity: 1, icon: 'ğŸ‘•' },
            { name: 'çš®ç”²', type: 'armor', def: 12, rarity: 1, icon: 'ğŸ¦º' },
            { name: 'æ¿ç”²', type: 'armor', def: 25, rarity: 1, icon: 'ğŸ›¡ï¸' },

            { name: 'çš®å¸½', type: 'helm', def: 3, rarity: 1, icon: 'ğŸ§¢' },
            { name: 'å…¨ç›”', type: 'helm', def: 8, rarity: 1, icon: 'ğŸª–' },

            { name: 'çš®æ‰‹å¥—', type: 'gloves', def: 2, rarity: 1, icon: 'ğŸ§¤' },
            { name: 'é‡æ‰‹å¥—', type: 'gloves', def: 5, rarity: 1, icon: 'ğŸ§¤' },

            { name: 'çš®é´', type: 'boots', def: 2, rarity: 1, icon: 'ğŸ‘¢' },
            { name: 'é”é“¾é´', type: 'boots', def: 6, rarity: 1, icon: 'ğŸ‘¢' },

            { name: 'è½»æ‰£å¸¦', type: 'belt', def: 2, rarity: 1, icon: 'ğŸ—ï¸' },
            { name: 'é‡è…°å¸¦', type: 'belt', def: 5, rarity: 1, icon: 'ğŸ¥‹' },

            { name: 'é“œæˆ’æŒ‡', type: 'ring', rarity: 1, icon: 'ğŸ’' },
            { name: 'æŠ¤èº«ç¬¦', type: 'amulet', rarity: 1, icon: 'ğŸ“¿' },

            { name: 'æ²»ç–—è¯å‰‚', type: 'potion', heal: 50, rarity: 0, stackable: true, icon: 'ğŸ”´' },
            { name: 'æ³•åŠ›è¯å‰‚', type: 'potion', mana: 30, rarity: 0, stackable: true, icon: 'ğŸ”µ' },
            { name: 'å›åŸå·è½´', type: 'scroll', rarity: 0, stackable: true, icon: 'ğŸ“œ' }
        ];
        const AFFIXES = {
            prefixes: [{ name: 'æ®‹å¿çš„', stat: 'dmgPct', min: 10, max: 30 }, { name: 'é‡è›®çš„', stat: 'str', min: 3, max: 8 }, { name: 'åšå›ºçš„', stat: 'def', min: 5, max: 15 }, { name: 'å¸è¡€çš„', stat: 'lifeSteal', min: 3, max: 5 }, { name: 'æ€¥é€Ÿçš„', stat: 'attackSpeed', min: 5, max: 15 }],
            suffixes: [{ name: 'ä¹‹ç†Š', stat: 'vit', min: 5, max: 10 }, { name: 'ä¹‹é¹°', stat: 'dex', min: 5, max: 10 }, { name: 'ä¹‹å¸è¡€', stat: 'lifeSteal', min: 3, max: 6 }, { name: 'ä¹‹æ€¥é€Ÿ', stat: 'attackSpeed', min: 5, max: 10 }, { name: 'ä¹‹åŠ›é‡', stat: 'str', min: 3, max: 6 }]
        };

        function init() {
            resize(); window.addEventListener('resize', resize);
            initDragging();
            SaveSystem.init();
        }
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }

        function startGame() {
            AudioSys.init();
            // å¯åŠ¨èƒŒæ™¯éŸ³ä¹ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’è§¦å‘ï¼‰
            // å»¶è¿Ÿä¸€ä¸‹ç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å®Œå…¨åˆå§‹åŒ–
            setTimeout(() => {
                AudioSys.startBGM();
            }, 100);
            document.getElementById('start-screen').style.display = 'none';
            if (window.pendingLoadData) {
                Object.assign(player, window.pendingLoadData);
                if (!player.equipment.helm) player.equipment.helm = null;
                if (!player.equipment.gloves) player.equipment.gloves = null;
                if (!player.equipment.boots) player.equipment.boots = null;
                if (!player.equipment.belt) player.equipment.belt = null;
                if (!player.equipment.amulet) player.equipment.amulet = null;

                if (!player.skills) player.skills = { fireball: 1, frostnova: 0, multishot: 0 };

                if (player.died === undefined) player.died = false; // åˆå§‹åŒ–æ­»äº¡æ ‡è®°

                if (!player.achievements) player.achievements = {}; // åˆå§‹åŒ–æˆå°±å­—æ®µ

                // åˆå§‹åŒ–æˆå°±æ•°æ®ç»“æ„
                initAchievements();

                if (player.questIndex === undefined) {
                    player.questIndex = 0; player.questState = 0; player.questProgress = 0;
                    if (player.quests && player.quests.q2 === 2) player.questIndex = QUEST_DB.length;
                }
                // Cleanup legacy
                if (player.quests) delete player.quests;

                // åŠ è½½ä»“åº“æ•°æ®ï¼ˆå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤ç©ºä»“åº“ï¼Œå¦‚æœå­˜æ¡£æ˜¯æ—§ç‰ˆ60æ ¼åˆ™æˆªæ–­ä¸º36æ ¼ï¼‰
                if (window.pendingLoadData.stash) {
                    // å¦‚æœå­˜æ¡£æ˜¯60æ ¼ï¼Œæˆªæ–­ä¸º36æ ¼
                    if (window.pendingLoadData.stash.length === 60) {
                        player.stash = window.pendingLoadData.stash.slice(0, 36);
                    } else {
                        player.stash = window.pendingLoadData.stash;
                    }
                } else if (!player.stash) {
                    player.stash = Array(36).fill(null);
                }

                if (window.pendingLoadData.townPortal) townPortal = window.pendingLoadData.townPortal;
                if (isNaN(player.xp)) player.xp = 0;
                if (isNaN(player.xpNext) || player.xpNext <= 0) player.xpNext = 100 * Math.pow(1.5, player.lvl - 1);
            }
            else {
                addItemToInventory(createItem('çŸ­å‰‘', 0)); addItemToInventory(createItem('æ²»ç–—è¯å‰‚', 0)); addItemToInventory(createItem('å›åŸå·è½´', 0));
                player.floor = 0;

                // æ–°æ¸¸æˆåˆå§‹åŒ–æˆå°±
                player.died = false;
                player.achievements = {};
                initAchievements();
            }
            updateStats(); enterFloor(player.floor, 'start'); renderInventory(); updateStatsUI(); updateSkillsUI(); updateUI(); updateBeltUI(); updateQuestUI(); updateMenuIndicators();
            gameActive = true; gameLoop(0); spawnEnemyTimer();
        }

        // Revised enterFloor with spawn point logic
        function enterFloor(f, spawnAt = 'start') {
            player.floor = f; enemies = []; groundItems = []; projectiles = []; npcs = [];

            // æˆå°±è¿½è¸ªï¼šåˆ°è¾¾æ¥¼å±‚
            trackAchievement('reach_floor', { floor: f });

            // ä¿®å¤ï¼šåˆ‡æ¢æ¥¼å±‚/æ­»äº¡å¤æ´»æ—¶ï¼Œå¼ºåˆ¶æ¸…ç©ºåœ°é¢çš„ç‰©å“æ ‡ç­¾
            document.getElementById('world-labels').innerHTML = '';

            if (f === 0) {
                document.getElementById('floor-display').innerText = "ç½—æ ¼è¥åœ°";
                generateTown();
                npcs.push({ x: dungeonEntrance.x - 100, y: dungeonEntrance.y - 100, name: "åŸºæ ¼", type: "merchant", radius: 20, frameIndex: 0 });
                npcs.push({ x: dungeonEntrance.x + 100, y: dungeonEntrance.y - 50, name: "é˜¿å¡æ‹‰", type: "healer", radius: 20, quest: 'q1', frameIndex: 1 });
                npcs.push({ x: dungeonEntrance.x, y: dungeonEntrance.y + 100, name: "ç“¦ç‘å¤«", type: "stash", radius: 20, frameIndex: 2 });
                showNotification("æ¬¢è¿å›åˆ°ç½—æ ¼è¥åœ°");

                // è¿›å…¥ç½—æ ¼è¥åœ°æ—¶ï¼Œç¡®ä¿BGMæ’­æ”¾
                AudioSys.resumeBGM();

                // éªŒè¯ä¼ é€é—¨ä½ç½®ï¼ˆå¦‚æœä»åœ°ç‰¢è¿”å›ï¼‰
                if (spawnAt === 'portal' && townPortal) {
                    const safePortalPos = validateAndFixPortalPosition(townPortal.x, townPortal.y);
                    townPortal.x = safePortalPos.x;
                    townPortal.y = safePortalPos.y;
                }

                if (spawnAt === 'end') { player.x = dungeonExit.x; player.y = dungeonExit.y + 40; }
                else if (spawnAt === 'portal') { if (townPortal) { player.x = townPortal.x; player.y = townPortal.y + 40; } else { player.x = dungeonEntrance.x; player.y = dungeonEntrance.y; } }
                else { player.x = dungeonEntrance.x; player.y = dungeonEntrance.y; }
            } else {
                document.getElementById('floor-display').innerText = `åœ°ç‰¢ ${f}å±‚`;

                generateDungeon();
                for (let i = 0; i < 15; i++) {
                    let x, y, v = false; while (!v) { x = Math.random() * MAP_WIDTH * TILE_SIZE; y = Math.random() * MAP_HEIGHT * TILE_SIZE; if (!isWall(x, y) && Math.hypot(x - dungeonEntrance.x, y - dungeonEntrance.y) > 300) v = true; }
                    let hp = 30 + Math.floor(f * f * 5);
                    enemies.push({
                        x, y, hp, maxHp: hp, dmg: 5 + f * 2, speed: 80, radius: 12,
                        dead: false, cooldown: 0, name: "æ²‰æ²¦é­”",
                        rarity: Math.random() < 0.1 ? 1 : 0, xpValue: 20 + f * 5,
                        frameIndex: MONSTER_FRAMES.melee
                    });
                }
                const currentQ = QUEST_DB[player.questIndex];
                if (currentQ && player.questState === 1 && currentQ.floor === f) {
                    if (currentQ.type === 'kill_elite' || currentQ.type === 'kill_boss') {
                        let x = dungeonExit.x, y = dungeonExit.y;
                        if (f !== 5 && f !== 10) { let v = false; while (!v) { x = Math.random() * MAP_WIDTH * TILE_SIZE; y = Math.random() * MAP_HEIGHT * TILE_SIZE; if (!isWall(x, y)) v = true; } }
                        let hp = Math.floor(100 + f * f * 15);
                        if (currentQ.id === 1) hp = 200;
                        if (currentQ.id === 3) hp = 400;
                        enemies.push({
                            x, y, hp, maxHp: hp, dmg: 15 + f * 2, speed: 90, radius: 25,
                            dead: false, cooldown: 0, name: currentQ.targetName,
                            isBoss: true, isQuestTarget: true, xpValue: 1000 + f * 200,
                            ai: 'chase', frameIndex: MONSTER_FRAMES.boss
                        });
                        showNotification(`è­¦å‘Šï¼šå‘ç°äº† ${currentQ.targetName}ï¼`);
                    }
                }
                showNotification(`è¿›å…¥ç¬¬ ${f} å±‚`);

                // è¿›å…¥åœ°ç‰¢æ—¶ï¼Œç¡®ä¿BGMæ’­æ”¾ï¼ˆå¦‚æœä¹‹å‰è¢«æš‚åœï¼‰
                AudioSys.resumeBGM();

                // éªŒè¯åœ°ç‰¢å±‚çš„ä¼ é€é—¨ä½ç½®ï¼ˆå¦‚æœä»ç½—æ ¼è¥åœ°ä¼ é€è¿‡æ¥ï¼‰
                if (spawnAt === 'portal' && townPortal) {
                    const safeDungeonPos = validateAndFixDungeonPortalPosition(townPortal.x, townPortal.y);
                    townPortal.x = safeDungeonPos.x;
                    townPortal.y = safeDungeonPos.y;
                }

                if (spawnAt === 'end') { player.x = dungeonExit.x; player.y = dungeonExit.y; }
                else if (spawnAt === 'portal') { if (townPortal) { player.x = townPortal.x; player.y = townPortal.y; } else { player.x = dungeonEntrance.x; player.y = dungeonEntrance.y; } }
                else { player.x = dungeonEntrance.x; player.y = dungeonEntrance.y; }
            }
            player.targetX = null; player.portalTimer = 1.0; updateQuestTracker(); SaveSystem.save();
        }

        function generateTown() {
            mapData = []; visitedMap = [];
            for (let y = 0; y < MAP_HEIGHT; y++) { mapData.push(new Array(MAP_WIDTH).fill(0)); visitedMap.push(new Array(MAP_WIDTH).fill(true)); }
            const cx = Math.floor(MAP_WIDTH / 2), cy = Math.floor(MAP_HEIGHT / 2); const r = 10;
            for (let y = cy - r; y <= cy + r; y++) for (let x = cx - r; x <= cx + r; x++) if (Math.hypot(x - cx, y - cy) < r) mapData[y][x] = 1;
            dungeonEntrance = { x: cx * TILE_SIZE, y: cy * TILE_SIZE }; dungeonExit = { x: cx * TILE_SIZE, y: (cy - r + 2) * TILE_SIZE };
        }

        // éªŒè¯å¹¶ä¿®æ­£ä¼ é€é—¨ä½ç½®ï¼Œç¡®ä¿åœ¨ç½—æ ¼è¥åœ°çš„æœ‰æ•ˆåŒºåŸŸå†…
        function validateAndFixPortalPosition(x, y) {
            // æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åœ¨ç½—æ ¼è¥åœ°çš„åœ†å½¢åŒºåŸŸå†…
            const cx = Math.floor(MAP_WIDTH / 2), cy = Math.floor(MAP_HEIGHT / 2);
            const r = 10;
            const tileX = Math.floor(x / TILE_SIZE), tileY = Math.floor(y / TILE_SIZE);
            const distFromCenter = Math.hypot(tileX - cx, tileY - cy);

            // å¦‚æœä½ç½®åœ¨æœ‰æ•ˆåŒºåŸŸå†…ï¼Œè¿”å›åŸä½ç½®
            if (distFromCenter < r) {
                return { x: x, y: y };
            }

            // å¦‚æœä½ç½®æ— æ•ˆï¼Œæ‰¾åˆ°æœ€è¿‘çš„åœ†å½¢è¾¹ç•Œä¸Šçš„æœ‰æ•ˆä½ç½®
            // è®¡ç®—ä»ä¸­å¿ƒåˆ°ç›®æ ‡ä½ç½®çš„æ–¹å‘å‘é‡
            const dx = tileX - cx, dy = tileY - cy;
            const dist = Math.hypot(dx, dy);

            if (dist > 0) {
                // å½’ä¸€åŒ–æ–¹å‘å‘é‡å¹¶ç¼©æ”¾åˆ°åœ†å½¢è¾¹ç•Œå†…
                const nx = dx / dist, ny = dy / dist;
                const targetX = cx + nx * (r - 1); // r-1 ç¡®ä¿åœ¨è¾¹ç•Œå†…
                const targetY = cy + ny * (r - 1);

                return {
                    x: Math.max(0, Math.min((MAP_WIDTH - 1) * TILE_SIZE, targetX * TILE_SIZE)),
                    y: Math.max(0, Math.min((MAP_HEIGHT - 1) * TILE_SIZE, targetY * TILE_SIZE))
                };
            } else {
                // å¦‚æœè·ç¦»ä¸º0ï¼ˆå°±åœ¨ä¸­å¿ƒï¼‰ï¼Œä½¿ç”¨é»˜è®¤çš„å®‰å…¨ä½ç½®
                return { x: cx * TILE_SIZE, y: cy * TILE_SIZE };
            }
        }

        // éªŒè¯å¹¶ä¿®æ­£åœ°ç‰¢å±‚çš„ä¼ é€é—¨ä½ç½®ï¼Œç¡®ä¿ä¸åœ¨å¢™é‡Œ
        function validateAndFixDungeonPortalPosition(x, y) {
            // é¦–å…ˆæ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦æœ‰æ•ˆï¼ˆä¸æ˜¯å¢™ï¼‰
            if (!isWall(x, y)) {
                return { x: x, y: y };
            }

            // å¦‚æœä½ç½®æ— æ•ˆï¼Œåœ¨é™„è¿‘å¯»æ‰¾æœ‰æ•ˆä½ç½®
            const searchRadius = 3; // æœç´¢åŠå¾„ï¼ˆæ ¼å­æ•°ï¼‰
            const centerTileX = Math.floor(x / TILE_SIZE);
            const centerTileY = Math.floor(y / TILE_SIZE);

            // èºæ—‹æœç´¢ï¼Œä»è¿‘åˆ°è¿œ
            for (let r = 1; r <= searchRadius; r++) {
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        // åªæ£€æŸ¥è¾¹ç•Œä¸Šçš„ç‚¹
                        if (Math.abs(dx) === r || Math.abs(dy) === r) {
                            const testTileX = centerTileX + dx;
                            const testTileY = centerTileY + dy;
                            const testX = testTileX * TILE_SIZE;
                            const testY = testTileY * TILE_SIZE;

                            // æ£€æŸ¥è¾¹ç•Œ
                            if (testTileX >= 0 && testTileX < MAP_WIDTH && testTileY >= 0 && testTileY < MAP_HEIGHT) {
                                if (!isWall(testX, testY)) {
                                    return { x: testX, y: testY };
                                }
                            }
                        }
                    }
                }
            }

            // å¦‚æœè¿˜æ˜¯æ²¡æ‰¾åˆ°ï¼Œä½¿ç”¨åœ°ç‰¢å…¥å£ä½œä¸ºåå¤‡æ–¹æ¡ˆ
            return { x: dungeonEntrance.x, y: dungeonEntrance.y };
        }

        function generateDungeon() {
            mapData = []; visitedMap = [];
            for (let y = 0; y < MAP_HEIGHT; y++) { mapData.push(new Array(MAP_WIDTH).fill(0)); visitedMap.push(new Array(MAP_WIDTH).fill(false)); }
            let floors = 0, target = MAP_WIDTH * MAP_HEIGHT * 0.3;
            let cx = Math.floor(MAP_WIDTH / 2), cy = Math.floor(MAP_HEIGHT / 2);
            dungeonEntrance = { x: cx * TILE_SIZE + TILE_SIZE / 2, y: cy * TILE_SIZE + TILE_SIZE / 2 };
            while (floors < target) {
                mapData[cy][cx] = 1; floors++;
                const d = Math.floor(Math.random() * 4);
                if (d === 0) cy--; else if (d === 1) cy++; else if (d === 2) cx--; else cx++;
                if (cx < 1) cx = 1; if (cx > MAP_WIDTH - 2) cx = MAP_WIDTH - 2; if (cy < 1) cy = 1; if (cy > MAP_HEIGHT - 2) cy = MAP_HEIGHT - 2;
                if (mapData[cy][cx] === 0) { mapData[cy][cx] = 1; floors++; }
            }
            let maxD = 0; let sx = Math.floor(dungeonEntrance.x / TILE_SIZE), sy = Math.floor(dungeonEntrance.y / TILE_SIZE);
            for (let y = 0; y < MAP_HEIGHT; y++) for (let x = 0; x < MAP_WIDTH; x++) if (mapData[y][x] === 1) { const d = Math.hypot(x - sx, y - sy); if (d > maxD) { maxD = d; dungeonExit.x = x * TILE_SIZE + TILE_SIZE / 2; dungeonExit.y = y * TILE_SIZE + TILE_SIZE / 2; } }
        }

        function gameLoop(ts) {
            if (!gameActive) return;
            const dt = Math.min((ts - lastTime) / 1000, 0.1); lastTime = ts;
            update(dt); draw();
            autoSaveTimer += dt; if (autoSaveTimer > 30) { SaveSystem.save(); autoSaveTimer = 0; }
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            mouse.worldX = mouse.x + camera.x; mouse.worldY = mouse.y + camera.y;
            if (player.hp < player.maxHp) player.hp += 0.5 * dt; if (player.mp < player.maxMp) player.mp += 1.5 * dt;
            if (player.attackCooldown > 0) player.attackCooldown -= dt;
            for (let k in player.skillCooldowns) if (player.skillCooldowns[k] > 0) player.skillCooldowns[k] -= dt;
            if (player.portalTimer > 0) player.portalTimer -= dt;

            interactionTarget = null;
            const distExit = Math.hypot(player.x - dungeonExit.x, player.y - dungeonExit.y);
            if (distExit < 60) {
                if (player.floor === 0) interactionTarget = { type: 'next', label: 'è¿›å…¥åœ°ç‰¢ 1å±‚' };
                else interactionTarget = { type: 'next', label: `è¿›å…¥åœ°ç‰¢ ${player.floor + 1}å±‚` };
            }
            if (player.floor > 0) {
                const distEnt = Math.hypot(player.x - dungeonEntrance.x, player.y - dungeonEntrance.y);
                if (distEnt < 60) {
                    const label = player.floor === 1 ? 'å›åˆ°ç½—æ ¼è¥åœ°' : `å›åˆ°åœ°ç‰¢ ${player.floor - 1}å±‚`;
                    interactionTarget = { type: 'prev', label: label };
                }
            }
            if (townPortal && townPortal.activeFloor === player.floor) {
                const distPortal = Math.hypot(player.x - townPortal.x, player.y - townPortal.y);
                if (distPortal < 60) {
                    const label = player.floor === 0 ? `ä¼ é€è‡³åœ°ç‰¢ ${townPortal.returnFloor}å±‚` : 'å›åˆ°ç½—æ ¼è¥åœ°';
                    interactionTarget = { type: 'portal', label: label };
                }
            }

            const promptEl = document.getElementById('interaction-msg');
            if (interactionTarget) {
                promptEl.style.display = 'block';
                promptEl.innerHTML = `æŒ‰ [Enter] ${interactionTarget.label}`;
            } else {
                promptEl.style.display = 'none';
            }

            for (let i = groundItems.length - 1; i >= 0; i--) {
                let item = groundItems[i];
                if (item.type === 'gold' && Math.hypot(item.x - player.x, item.y - player.y) < 60) {
                    player.gold += item.val;
                    createDamageNumber(player.x, player.y - 40, `+${item.val} G`, 'gold');
                    AudioSys.play('gold');
                    if (item.el) item.el.remove();
                    groundItems.splice(i, 1);
                }
            }

            if (mouse.leftDown && !isHoveringUI()) {
                const t = getEnemyAtCursor();
                const npc = getNPCAtCursor();
                if (npc && Math.hypot(npc.x - player.x, npc.y - player.y) < 60) {
                    player.targetX = null; interactNPC(npc);
                } else if (t) {
                    if (Math.hypot(t.x - player.x, t.y - player.y) < 50) { player.targetX = null; performAttack(t); }
                    else { player.targetX = t.x; player.targetY = t.y; }
                } else { player.targetX = mouse.worldX; player.targetY = mouse.worldY; }
            }

            if (player.targetX !== null) {
                const dx = player.targetX - player.x, dy = player.targetY - player.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 5) {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        player.direction = dx > 0 ? 'right' : 'left';
                    } else {
                        player.direction = dy > 0 ? 'front' : 'back';
                    }
                    const move = player.speed * dt;
                    const nx = player.x + (dx / dist) * move, ny = player.y + (dy / dist) * move;
                    if (!isWall(nx, player.y)) player.x = nx;
                    if (!isWall(player.x, ny)) player.y = ny;
                    if (isWall(nx, ny) && isWall(nx, player.y) && isWall(player.x, ny)) player.targetX = null;
                } else player.targetX = null;
            }

            const pc = Math.floor(player.x / TILE_SIZE), pr = Math.floor(player.y / TILE_SIZE);
            for (let y = pr - 8; y <= pr + 8; y++) for (let x = pc - 8; x <= pc + 8; x++) if (y >= 0 && y < MAP_HEIGHT && x >= 0 && x < MAP_WIDTH && mapData[y][x]) visitedMap[y][x] = true;
            camera.x = player.x - canvas.width / 2; camera.y = player.y - canvas.height / 2;

            updateEnemies(dt);

            projectiles.forEach((p, i) => {
                p.life -= dt; p.x += Math.cos(p.angle) * p.speed * dt; p.y += Math.sin(p.angle) * p.speed * dt;
                if (isWall(p.x, p.y)) { p.life = 0; for (let j = 0; j < 3; j++)createParticle(p.x, p.y, '#aaa', 2); }

                // å¦‚æœæŠ•å°„ç‰©æœ‰ownerï¼ˆæ€ªç‰©å‘å°„çš„ï¼‰ï¼Œæ£€æµ‹æ˜¯å¦å‡»ä¸­ç©å®¶
                if (p.owner && p.owner !== player) {
                    if (Math.hypot(p.x - player.x, p.y - player.y) < player.radius + 10) {
                        player.hp -= Math.max(0, p.damage - player.armor * 0.1);
                        p.life = 0;
                        createDamageNumber(player.x, player.y - 20, Math.floor(p.damage), '#ff0000');
                        AudioSys.play('hit');
                        updateUI(); checkPlayerDeath();
                        for (let j = 0; j < 5; j++)createParticle(p.x, p.y, p.color || '#ff4400');
                    }
                } else {
                    // ç©å®¶å‘å°„çš„æŠ•å°„ç‰©ï¼Œæ£€æµ‹æ˜¯å¦å‡»ä¸­æ•Œäºº
                    enemies.forEach(e => {
                        if (!e.dead && e !== p.owner && Math.hypot(p.x - e.x, p.y - e.y) < e.radius + 10) {
                            takeDamage(e, p.damage); p.life = 0;
                            if (p.freeze) { e.frozenTimer = p.freeze; createDamageNumber(e.x, e.y - 40, "å†»ç»“!", COLORS.ice); }
                            for (let j = 0; j < 5; j++)createParticle(p.x, p.y, p.color || '#ff4400');
                        }
                    });
                }

                if (p.life <= 0) projectiles.splice(i, 1);
            });

            particles.forEach((p, i) => { p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt; if (p.life <= 0) particles.splice(i, 1) });
            damageNumbers.forEach((d, i) => { d.life -= dt; d.y -= 20 * dt; if (d.life <= 0) damageNumbers.splice(i, 1); });

            // å®šæœŸæ¸…ç†æ­»äº¡çš„æ€ªç‰©ï¼Œé˜²æ­¢æ•°ç»„æ— é™å¢é•¿
            enemies = enemies.filter(e => !e.dead || (e.dead && Math.hypot(e.x - player.x, e.y - player.y) < 500));

            updateUI();
        }

        function updateEnemies(dt) {
            enemies.forEach(e => {
                if (e.dead) return;
                if (e.frozenTimer > 0) { e.frozenTimer -= dt; return; }
                if (e.cooldown > 0) e.cooldown -= dt;

                const dist = Math.hypot(player.x - e.x, player.y - e.y);

                if (e.ai === 'ranged') {
                    if (dist < 150) {
                        const dx = e.x - player.x, dy = e.y - player.y;
                        const moveX = e.x + (dx / dist) * e.speed * dt;
                        const moveY = e.y + (dy / dist) * e.speed * dt;
                        if (!isWall(moveX, e.y)) e.x = moveX; if (!isWall(e.x, moveY)) e.y = moveY;
                    } else if (dist < 400) {
                        if (e.cooldown <= 0) {
                            const angle = Math.atan2(player.y - e.y, player.x - e.x);
                            projectiles.push({
                                x: e.x,
                                y: e.y,
                                angle: angle,
                                speed: 250,
                                life: 2,
                                damage: e.dmg,
                                color: '#ffaa00',
                                owner: e
                            });
                            AudioSys.play('arrow');
                            e.cooldown = 2.0;
                        }
                    }
                } else if (e.ai === 'revive') {
                    if (e.cooldown <= 0) {
                        const body = enemies.find(other => other.dead && Math.hypot(other.x - e.x, other.y - e.y) < 200);
                        if (body) {
                            body.dead = false; body.hp = body.maxHp;
                            createDamageNumber(body.x, body.y - 20, "å¤æ´»!", '#ff00ff');
                            e.cooldown = 5.0;
                            return;
                        }
                    }
                    if (dist < 300 && dist > 100) {
                        const nx = e.x + ((player.x - e.x) / dist) * e.speed * dt, ny = e.y + ((player.y - e.y) / dist) * e.speed * dt;
                        if (!isWall(nx, e.y)) e.x = nx; if (!isWall(e.x, ny)) e.y = ny;
                    }
                } else {
                    if (dist < 400 && dist > 35) {
                        const nx = e.x + ((player.x - e.x) / dist) * e.speed * dt, ny = e.y + ((player.y - e.y) / dist) * e.speed * dt;
                        if (!isWall(nx, e.y)) e.x = nx; if (!isWall(e.x, ny)) e.y = ny;
                    }
                    if (dist <= 40 && e.cooldown <= 0) {
                        player.hp -= Math.max(0, e.dmg - player.armor * 0.1); e.cooldown = 1.5;
                        createDamageNumber(player.x, player.y - 20, Math.floor(e.dmg), '#ff0000');
                        AudioSys.play('hit');
                        updateUI(); checkPlayerDeath();
                    }
                }
            });
        }

        // --- Rendering ---
        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(-camera.x, -camera.y);

            const sc = Math.floor(camera.x / TILE_SIZE), ec = sc + (canvas.width / TILE_SIZE) + 1;
            const sr = Math.floor(camera.y / TILE_SIZE), er = sr + (canvas.height / TILE_SIZE) + 1;
            for (let r = sr - 1; r < er + 1; r++) {
                for (let c = sc - 1; c < ec + 1; c++) {
                    if (r >= 0 && r < MAP_HEIGHT && c >= 0 && c < MAP_WIDTH) {
                        const x = c * TILE_SIZE, y = r * TILE_SIZE;
                        if (mapData[r][c] === 0) { ctx.fillStyle = COLORS.wall; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); ctx.fillStyle = '#111'; ctx.fillRect(x, y + TILE_SIZE - 10, TILE_SIZE, 10); }
                        else { ctx.fillStyle = ((c + r) % 2 === 0) ? '#151515' : '#1a1a1a'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); }
                    }
                }
            }

            // Render Exits
            if (player.floor === 0) {
                ctx.fillStyle = COLORS.exit; ctx.fillRect(dungeonExit.x - 15, dungeonExit.y - 15, 30, 30);
                ctx.strokeStyle = '#4d94ff'; ctx.strokeRect(dungeonExit.x - 15, dungeonExit.y - 15, 30, 30);
                ctx.fillStyle = '#aaa'; ctx.textAlign = 'center'; ctx.fillText("å»åœ°ç‰¢ 1å±‚", dungeonExit.x, dungeonExit.y - 20);
            } else {
                ctx.fillStyle = COLORS.exit; ctx.fillRect(dungeonExit.x - 15, dungeonExit.y - 15, 30, 30);
                ctx.strokeStyle = '#4d94ff'; ctx.strokeRect(dungeonExit.x - 15, dungeonExit.y - 15, 30, 30);
                ctx.fillStyle = COLORS.entrance; ctx.fillRect(dungeonEntrance.x - 15, dungeonEntrance.y - 15, 30, 30);
                ctx.strokeStyle = '#ffaa00'; ctx.strokeRect(dungeonEntrance.x - 15, dungeonEntrance.y - 15, 30, 30);
                let prevLabel = player.floor === 1 ? "å»ç½—æ ¼è¥åœ°" : `å»åœ°ç‰¢ ${player.floor - 1}å±‚`;
                ctx.fillStyle = '#aaa'; ctx.textAlign = 'center'; ctx.fillText(prevLabel, dungeonEntrance.x, dungeonEntrance.y - 20);
            }

            if (townPortal && townPortal.activeFloor === player.floor) {
                ctx.fillStyle = '#4d94ff'; ctx.beginPath(); ctx.arc(townPortal.x, townPortal.y, 10, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.stroke();
                let label = player.floor === 0 ? `ä¼ é€é—¨ (å»å¾€ ${townPortal.returnFloor}å±‚)` : "ä¼ é€é—¨ (å›ç½—æ ¼è¥åœ°)";
                ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.fillText(label, townPortal.x, townPortal.y - 20);
            }

            groundItems.forEach(i => {
                ctx.beginPath(); ctx.fillStyle = getItemColor(i.rarity); ctx.textAlign = 'center';
                ctx.font = '20px serif'; ctx.fillText(i.icon || 'ğŸ“¦', i.x, i.y + 7);
                if (i.rarity >= 3) { ctx.globalAlpha = 0.2; ctx.beginPath(); ctx.moveTo(i.x, i.y); ctx.lineTo(i.x - 10, i.y - 100); ctx.lineTo(i.x + 10, i.y - 100); ctx.fill(); ctx.globalAlpha = 1; }
            });

            npcs.forEach(n => {
                if (spritesLoaded && processedSpriteSheet && n.frameIndex !== undefined) {
                    const frame = getNPCFrame(n.frameIndex);
                    const renderHeight = 52;
                    const renderWidth = renderHeight * frame.width / frame.height;
                    ctx.drawImage(processedSpriteSheet, frame.x, frame.y, frame.width, frame.height,
                        n.x - renderWidth / 2, n.y - renderHeight, renderWidth, renderHeight);
                } else {
                    ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.arc(n.x, n.y, 15, 0, Math.PI * 2); ctx.fill();
                }

                // Quest Indicators (above name)
                if (n.type === 'healer') {
                    if (player.questState === 0 && player.questIndex < QUEST_DB.length) {
                        ctx.fillStyle = '#ffff00'; ctx.font = '20px Arial'; ctx.fillText("!", n.x, n.y - 80);
                    } else if (player.questState === 2) {
                        ctx.fillStyle = '#ffff00'; ctx.font = '20px Arial'; ctx.fillText("?", n.x, n.y - 80);
                    }
                }

                // Name (above character)
                ctx.fillStyle = '#fff'; ctx.font = '12px Cinzel'; ctx.textAlign = 'center'; ctx.fillText(n.name, n.x, n.y - 70);
            });

            enemies.forEach(e => {
                if (e.dead) { ctx.fillStyle = '#330000'; ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.fill(); return; }

                if (spritesLoaded && processedSpriteSheet && e.frameIndex !== undefined) {
                    const frame = getMonsterFrame(e.frameIndex);
                    const renderHeight = 44;
                    const renderWidth = renderHeight * frame.width / frame.height;
                    ctx.drawImage(processedSpriteSheet, frame.x, frame.y, frame.width, frame.height,
                        e.x - renderWidth / 2, e.y - renderHeight, renderWidth, renderHeight);
                } else {
                    ctx.fillStyle = e.frozenTimer > 0 ? COLORS.ice : (e.rarity > 0 ? '#ffaa00' : (e.isBoss ? '#9000cc' : '#880000'));
                    if (e.isQuestTarget) ctx.fillStyle = '#ff00aa';
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.fill();
                }

                ctx.fillStyle = '#500'; ctx.fillRect(e.x - 15, e.y - e.radius - 8, 30, 4);
                ctx.fillStyle = '#f00'; ctx.fillRect(e.x - 15, e.y - e.radius - 8, 30 * (e.hp / e.maxHp), 4);
                ctx.fillStyle = e.isBoss ? '#f33' : (e.rarity > 0 ? '#fa0' : '#ccc');
                ctx.font = '10px Cinzel';
                ctx.textAlign = 'center';
                ctx.fillText(e.name, e.x, e.y - e.radius - 35);
            });

            if (player.targetX !== null) { ctx.strokeStyle = '#333'; ctx.beginPath(); ctx.arc(player.targetX, player.targetY, 5, 0, Math.PI * 2); ctx.stroke(); }
            if (spritesLoaded && processedSpriteSheet) {
                const frame = getHeroFrame(player.direction);
                const renderHeight = 48;
                const renderWidth = renderHeight * frame.width / frame.height;
                ctx.drawImage(processedSpriteSheet, frame.x, frame.y, frame.width, frame.height,
                    player.x - renderWidth / 2, player.y - renderHeight, renderWidth, renderHeight);
            } else {
                ctx.fillStyle = player.color; ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2); ctx.fill();
            }

            projectiles.forEach(p => {
                ctx.strokeStyle = p.color || '#fa0';
                ctx.fillStyle = p.color || '#fa0';
                ctx.lineWidth = 2;

                // ç®­çŸ¢æŠ•å°„ç‰©ï¼ˆæ€ªç‰©å‘å°„ï¼‰- ç”»æˆçº¿æ¡
                if (p.color === '#ffaa00' && p.owner !== player) {
                    const len = 15;
                    const endX = p.x - Math.cos(p.angle) * len;
                    const endY = p.y - Math.sin(p.angle) * len;
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                } else {
                    // ç«çƒç­‰æŠ•å°„ç‰© - ç”»æˆåœ†å½¢
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); });
            ctx.globalAlpha = 1;

            ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
            damageNumbers.forEach(d => { ctx.fillStyle = d.color; ctx.fillText(d.val, d.x, d.y); });

            ctx.restore();

            const g = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 200, canvas.width / 2, canvas.height / 2, canvas.width / 1.2);
            g.addColorStop(0, 'rgba(0,0,0,0)'); g.addColorStop(1, 'rgba(0,0,0,0.85)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

            updateLabelsPosition();
            drawMinimap();
        }

        function updateLabelsPosition() {
            groundItems.forEach(i => {
                if (i.el) {
                    const sx = i.x - camera.x, sy = i.y - camera.y;
                    if (sx > 0 && sx < canvas.width && sy > 0 && sy < canvas.height) {
                        i.el.style.display = 'block'; i.el.style.left = sx + 'px'; i.el.style.top = sy + 'px';
                    } else i.el.style.display = 'none';
                }
            });
        }

        function drawMinimap() {
            miniCtx.fillStyle = '#000'; miniCtx.fillRect(0, 0, 150, 150);
            const s = 150 / MAP_WIDTH;
            for (let y = 0; y < MAP_HEIGHT; y++) for (let x = 0; x < MAP_WIDTH; x++) {
                if (visitedMap[y][x]) {
                    miniCtx.fillStyle = mapData[y][x] === 0 ? '#444' : '#111';
                    miniCtx.fillRect(x * s, y * s, s, s);
                }
            }
            const ex = Math.floor(dungeonExit.x / TILE_SIZE), ey = Math.floor(dungeonExit.y / TILE_SIZE);
            if (visitedMap[ey][ex]) { miniCtx.fillStyle = COLORS.exit; miniCtx.fillRect(ex * s, ey * s, s, s); }
            const px = player.x / TILE_SIZE * s, py = player.y / TILE_SIZE * s;
            miniCtx.fillStyle = '#0f0'; miniCtx.fillRect(px - 1, py - 1, 3, 3);
            miniCtx.fillStyle = '#f00';
            enemies.forEach(e => { if (!e.dead) { const ex = Math.floor(e.x / TILE_SIZE), ey = Math.floor(e.y / TILE_SIZE); if (ex >= 0 && visitedMap[ey][ex]) miniCtx.fillRect(ex * s, ey * s, 2, 2); } });
        }

        function interactNPC(npc) {
            if (npc.type === 'merchant') {
                togglePanel('shop');
            } else if (npc.type === 'stash') {
                togglePanel('stash');
                renderStash();
            } else if (npc.type === 'healer') {
                const currentQ = QUEST_DB[player.questIndex];

                if (!currentQ) {
                    showDialog(npc.name, "ä½ å·²ç»å®Œæˆäº†æ‰€æœ‰ä»»åŠ¡ï¼ŒçœŸæ­£çš„è‹±é›„ï¼", [{ text: "è°¢è°¢", action: closeDialog }]);
                    return;
                }

                if (player.questState === 0) {
                    showDialog(npc.name, `å‹‡å£«ï¼Œæˆ‘ä»¬éœ€è¦ä½ çš„å¸®åŠ©ã€‚\n\n${currentQ.desc}\n\nå¥–åŠ±: ${currentQ.reward}`,
                        [{ text: "æ¥å—ä»»åŠ¡", action: () => { player.questState = 1; player.questProgress = 0; updateQuestUI(); updateQuestTracker(); updateMenuIndicators(); closeDialog(); } }]);
                } else if (player.questState === 1) {
                    let progText = "";
                    if (currentQ.type === 'kill_count') progText = ` (è¿›åº¦: ${player.questProgress} / ${currentQ.target})`;
                    showDialog(npc.name, `ä»»åŠ¡è¿˜æ²¡å®Œæˆã€‚å¿«å»ï¼\n${currentQ.desc}${progText}`, [{ text: "å¥½çš„", action: closeDialog }]);
                } else if (player.questState === 2) {
                    showDialog(npc.name, "å¹²å¾—æ¼‚äº®ï¼è¿™æ˜¯ç»™ä½ çš„å¥–åŠ±ã€‚",
                        [{
                            text: "é¢†å–å¥–åŠ±", action: () => {
                                if (currentQ.reward.includes('æŠ€èƒ½ç‚¹')) {
                                    if (currentQ.reward.includes('2')) {
                                        player.skillPoints += 2;
                                    } else {
                                        player.skillPoints++;
                                    }
                                }
                                if (currentQ.reward.includes('é‡‘å¸')) {
                                    if (currentQ.reward.includes('1000')) {
                                        player.gold += 1000;
                                    } else {
                                        player.gold += 500;
                                    }
                                }
                                if (currentQ.reward.includes('è£…å¤‡') || currentQ.reward.includes('æˆ’æŒ‡') || currentQ.reward.includes('ç¬¦æ–‡') || currentQ.reward.includes('é¥°å“')) {
                                    addItemToInventory(createItem('æˆ’æŒ‡', player.lvl));
                                }
                                if (currentQ.reward.includes('æš—é‡‘è£…å¤‡') || currentQ.reward.includes('ä¼ å¥‡è£…å¤‡') || currentQ.reward.includes('ç»ˆæç¥è£…')) {
                                    let item;
                                    if (currentQ.reward.includes('æš—é‡‘')) {
                                        item = createItem('æˆ’æŒ‡', player.lvl);
                                        item.rarity = 3; // ç¨€æœ‰
                                    } else if (currentQ.reward.includes('ä¼ å¥‡')) {
                                        item = createItem('æˆ’æŒ‡', player.lvl);
                                        item.rarity = 4; // æš—é‡‘
                                    } else { // ç»ˆæç¥è£…
                                        item = createItem('æˆ’æŒ‡', player.lvl);
                                        item.rarity = 4;
                                        item.displayName = "ç»ˆæç¥è£…";
                                    }
                                    addItemToInventory(item);
                                }

                                player.questIndex++;
                                player.questState = 0;
                                player.questProgress = 0;

                                updateSkillsUI(); updateQuestUI(); updateQuestTracker(); updateMenuIndicators(); closeDialog(); AudioSys.play('levelup');
                            }
                        }]);
                } else {
                    player.hp = player.maxHp; player.mp = player.maxMp; showNotification("é˜¿å¡æ‹‰æ²»æ„ˆäº†ä½ ");
                }
            }
        }

        function showDialog(name, text, options) {
            const box = document.getElementById('dialog-box');
            document.getElementById('dialog-name').innerText = name;
            document.getElementById('dialog-text').innerText = text;
            const optsDiv = document.getElementById('dialog-options');
            optsDiv.innerHTML = '';
            options.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'dialog-btn';
                btn.innerText = opt.text;
                btn.onclick = (e) => {
                    e.stopPropagation();
                    opt.action();
                };
                btn.onmousedown = (e) => e.stopPropagation();
                optsDiv.appendChild(btn);
            });
            box.style.display = 'block';
        }
        function closeDialog() { document.getElementById('dialog-box').style.display = 'none'; }

        function updateQuestUI() {
            const list = document.getElementById('quest-list');
            list.innerHTML = '';

            QUEST_DB.forEach((q, idx) => {
                if (idx > player.questIndex) return;

                const d = document.createElement('div');
                d.className = 'quest-item';

                let statusText = "æœªå¼€å§‹";
                let colorClass = "";

                if (idx < player.questIndex) {
                    statusText = "å·²å®Œæˆ"; colorClass = "completed";
                } else {
                    if (player.questState === 0) statusText = "å¾…æ¥å—";
                    else if (player.questState === 1) {
                        statusText = "è¿›è¡Œä¸­";
                        if (q.type === 'kill_count') statusText += ` (${player.questProgress}/${q.target})`;
                    }
                    else if (player.questState === 2) { statusText = "å¯äº¤ä»˜"; colorClass = "completed"; }
                }

                d.innerHTML = `<div class="quest-title">${q.title} <span class="quest-status ${colorClass}">(${statusText})</span></div><div style="font-size:12px; color:#aaa;">${q.desc}</div><div style="font-size:12px; color:#gold;">å¥–åŠ±: ${q.reward}</div>`;
                list.appendChild(d);
            });
        }

        function updateQuestTracker() {
            const el = document.getElementById('quest-tracker');
            el.innerHTML = '';

            const currentQ = QUEST_DB[player.questIndex];
            if (!currentQ || player.questState === 0) return;

            let text = "";
            let titleColor = "#c7b377";

            if (player.questState === 2) {
                text = "å›å»æ‰¾é˜¿å¡æ‹‰";
                titleColor = "#0f0";
            } else {
                if (currentQ.type === 'kill_count') {
                    text = `è¿›åº¦: ${player.questProgress} / ${currentQ.target}`;
                    if (player.floor !== currentQ.floor) text += ` (ç›®æ ‡åœ¨: åœ°ç‰¢ ${currentQ.floor}å±‚)`;
                } else if (currentQ.type === 'kill_elite' || currentQ.type === 'kill_boss') {
                    text = `ç›®æ ‡: ${currentQ.targetName}`;
                    if (player.floor !== currentQ.floor) text += ` (ç›®æ ‡åœ¨: åœ°ç‰¢ ${currentQ.floor}å±‚)`;
                }
            }

            el.innerHTML += `<div><span class="tracker-title" style="color:${titleColor}">${currentQ.title}</span><br><span class="tracker-desc">${text}</span></div>`;
        }

        function renderAchievements() {
            const list = document.getElementById('achievement-list');
            if (!list) return;
            list.innerHTML = '';

            ACHIEVEMENTS.forEach(ach => {
                const progress = player.achievements[ach.id];
                if (!progress) return;

                const div = document.createElement('div');
                div.className = 'achievement-item' + (progress.completed ? ' completed' : '');

                let progressText = '';
                if (ach.type === 'collect_unique_set') {
                    const uniqueItems = [];
                    Object.values(player.equipment).forEach(item => {
                        if (item && item.unique) uniqueItems.push(item);
                    });
                    progressText = `${uniqueItems.length} / 8 è£…å¤‡æ ä½`;
                } else if (ach.type === 'reach_floor') {
                    progressText = progress.completed ? 'å·²å®Œæˆ' : `å½“å‰ ${player.floor} / ${ach.target} å±‚`;
                } else if (ach.type === 'no_death_floor') {
                    progressText = progress.completed ? 'å·²å®Œæˆ' : `æœªæ­»äº¡åˆ°è¾¾ç¬¬${player.floor}å±‚`;
                } else if (ach.type === 'reach_level') {
                    progressText = progress.completed ? 'å·²å®Œæˆ' : `å½“å‰ç­‰çº§ ${player.lvl} / ${ach.target}`;
                } else {
                    progressText = `${progress.progress || 0} / ${ach.target}`;
                }

                div.innerHTML = `
                    <div class="ach-name">${ach.name}</div>
                    <div class="ach-desc">${ach.description}</div>
                    <div class="ach-progress">${progressText}</div>
                `;
                list.appendChild(div);
            });
        }

        // New function for indicators
        function updateMenuIndicators() {
            document.getElementById('badge-stats').style.display = player.points > 0 ? 'block' : 'none';
            document.getElementById('badge-skills').style.display = player.skillPoints > 0 ? 'block' : 'none';
            document.getElementById('badge-quest').style.display = player.questState === 2 ? 'block' : 'none';
        }

        function spawnEnemyTimer() {
            setInterval(() => {
                // è®¡ç®—å­˜æ´»çš„æ€ªç‰©æ•°é‡ï¼Œè€Œä¸æ˜¯æ€»çš„æ€ªç‰©æ•°ç»„é•¿åº¦
                const aliveEnemies = enemies.filter(e => !e.dead).length;
                if (!gameActive || aliveEnemies > 20 || player.floor === 0) return;

                let x, y, v = false; while (!v) { x = Math.random() * MAP_WIDTH * TILE_SIZE; y = Math.random() * MAP_HEIGHT * TILE_SIZE; if (!isWall(x, y)) v = true; }
                if (Math.hypot(x - player.x, y - player.y) < 300) return;

                const f = player.floor;
                const hp = 30 + Math.floor(f * f * 5);
                const dmg = 5 + f * 2;
                const xp = 20 + f * 5;

                const rand = Math.random();
                let type = 'melee';
                let name = 'æ²‰æ²¦é­”';
                let ai = 'chase';
                let speed = 80;

                if (f >= 2 && rand < 0.3) { type = 'ranged'; name = 'éª·é«…å¼“ç®­æ‰‹'; ai = 'ranged'; speed = 70; }
                if (f >= 3 && rand < 0.1) { type = 'shaman'; name = 'æ²‰æ²¦é­”å·«å¸ˆ'; ai = 'revive'; speed = 60; }

                let frameIndex = MONSTER_FRAMES[type];
                const isElite = Math.random() < 0.1;
                if (isElite || type === 'elite' || type === 'boss') {
                    frameIndex = MONSTER_FRAMES.elite;
                    name = isElite ? `ç²¾è‹±${name}` : name;
                }

                enemies.push({
                    x, y, hp, maxHp: hp, dmg, speed, radius: 12,
                    dead: false, cooldown: 0, name, rarity: isElite ? 1 : 0, xpValue: xp,
                    ai: ai, frameIndex: frameIndex
                });
            }, 2000);
        }

        function takeDamage(e, dmg) {
            e.hp -= dmg; createDamageNumber(e.x, e.y, dmg, '#fff'); AudioSys.play('hit');
            if (e.hp <= 0) {
                e.dead = true;
                const xpGain = e.xpValue || 15; player.xp += xpGain; createDamageNumber(player.x, player.y - 50, "+" + xpGain + " XP", '#4d69cd');
                dropLoot(e);
                checkLevelUp();

                // QUEST LOGIC
                const currentQ = QUEST_DB[player.questIndex];
                if (currentQ && player.questState === 1) {
                    let progressMade = false;

                    if (currentQ.type === 'kill_count' && player.floor === currentQ.floor) {
                        player.questProgress++;
                        if (player.questProgress >= currentQ.target) {
                            player.questState = 2;
                            showNotification("ä»»åŠ¡å®Œæˆï¼");
                            AudioSys.play('quest');
                        }
                        progressMade = true;
                    } else if ((currentQ.type === 'kill_elite' || currentQ.type === 'kill_boss') && e.isQuestTarget) {
                        player.questState = 2;
                        showNotification(`å‡»è´¥äº† ${e.name}ï¼`);
                        AudioSys.play('quest');
                        progressMade = true;
                    }

                    if (progressMade) { updateQuestTracker(); updateMenuIndicators(); }
                }
            }
        }

        function showNotification(msg) {
            const el = document.getElementById('notification-area');
            el.innerText = msg; el.style.opacity = 1; setTimeout(() => el.style.opacity = 0, 2000);
        }

        function createItem(baseName, level) {
            let base = BASE_ITEMS.find(i => i.name === baseName) || BASE_ITEMS[Math.floor(Math.random() * BASE_ITEMS.length)];
            let item = { ...base, id: Math.random().toString(36), stats: {}, displayName: base.name, quantity: 1 };

            if (!item.icon) {
                if (item.type === 'weapon') item.icon = 'âš”ï¸';
                if (item.type === 'armor') item.icon = 'ğŸ›¡ï¸';
                if (item.type === 'ring') item.icon = 'ğŸ’';
            }

            if (level > 1) {
                if (item.minDmg) { item.minDmg += level; item.maxDmg += level * 2; }
                if (item.def) item.def += level;
            }
            if (item.type !== 'potion' && item.type !== 'scroll') {
                const rand = Math.random(); item.rarity = rand < 0.05 ? 4 : rand < 0.2 ? 3 : rand < 0.5 ? 2 : 1;
            }
            if (item.rarity >= 2) {
                const p = AFFIXES.prefixes[Math.floor(Math.random() * AFFIXES.prefixes.length)];
                item.displayName = p.name + " " + item.name; item.stats[p.stat] = Math.floor(Math.random() * (p.max - p.min)) + p.min;
            }
            if (item.rarity >= 3) {
                const s = AFFIXES.suffixes[Math.floor(Math.random() * AFFIXES.suffixes.length)];
                item.displayName += s.name; item.stats[s.stat] = (item.stats[s.stat] || 0) + Math.floor(Math.random() * (s.max - s.min)) + s.min;
            }
            if (item.rarity === 4) { item.displayName = "æš—é‡‘Â·" + item.name; item.stats.allSkills = 1; item.stats.str = 10; item.stats.lifeSteal = 5; }
            return item;
        }

        function addItemToInventory(i) {
            if (i.stackable) {
                const existing = player.inventory.find(invItem => invItem && invItem.name === i.name);
                if (existing) { existing.quantity = (existing.quantity || 1) + 1; renderInventory(); updateBeltUI(); AudioSys.play('gold'); return true; }
            }
            const idx = player.inventory.findIndex(x => !x); if (idx < 0) return false; player.inventory[idx] = i; renderInventory(); updateBeltUI(); AudioSys.play('gold'); return true;
        }

        function createDamageNumber(x, y, val, color) { damageNumbers.push({ x, y, val, color, life: 1 }); }
        function createParticle(x, y, color, size = 3) { particles.push({ x, y, color, vx: (Math.random() - 0.5) * 100, vy: (Math.random() - 0.5) * 100, life: 0.5, size }); }
        function checkPlayerDeath() {
            if (player.hp <= 0) {
                // æ ‡è®°ç©å®¶æ›¾ç»æ­»äº¡
                player.died = true;
                alert("ä½ æ­»äº†ï¼çµé­‚å›åˆ°äº†ç½—æ ¼è¥åœ°ã€‚");
                player.hp = player.maxHp;
                player.gold = Math.floor(player.gold / 2);
                enterFloor(0);
            }
        }

        function renderStash() {
            const c = document.getElementById('stash-grid');
            c.innerHTML = '';

            player.stash.forEach((item, idx) => {
                const slot = document.createElement('div');
                slot.className = 'bag-slot';

                if (item) {
                    slot.innerText = item.icon || ITEM_TYPES[item.type.toUpperCase()].icon;
                    slot.style.color = getItemColor(item.rarity);
                    slot.style.display = 'flex';
                    slot.style.justifyContent = 'center';
                    slot.style.alignItems = 'center';
                    slot.style.fontSize = '24px';

                    if (item.quantity && item.quantity > 1) {
                        slot.innerHTML += `<span class="item-count">${item.quantity}</span>`;
                    }

                    slot.onclick = (e) => {
                        e.stopPropagation();
                        moveItemFromStash(idx);
                    };
                    slot.onmouseenter = (e) => showTooltip(item, e);
                    slot.onmouseleave = hideTooltip;
                    slot.onmousedown = (e) => e.stopPropagation();
                }

                c.appendChild(slot);
            });
        }

        function moveItemToStash(inventoryIdx) {
            const item = player.inventory[inventoryIdx];
            if (!item) return;

            // å¯»æ‰¾ä»“åº“ç©ºä½
            const stashIdx = player.stash.findIndex(i => !i);
            if (stashIdx === -1) {
                showNotification('ä»“åº“å·²æ»¡ï¼');
                return;
            }

            // ç§»åŠ¨ç‰©å“
            player.stash[stashIdx] = item;
            player.inventory[inventoryIdx] = null;

            // åˆ·æ–°UI
            renderInventory();
            renderStash();
            showNotification(`å·²å°† ${item.displayName || item.name} å­˜å…¥ä»“åº“`);
        }

        function moveItemFromStash(stashIdx) {
            const item = player.stash[stashIdx];
            if (!item) return;

            // å¯»æ‰¾èƒŒåŒ…ç©ºä½
            const inventoryIdx = player.inventory.findIndex(i => !i);
            if (inventoryIdx === -1) {
                showNotification('èƒŒåŒ…å·²æ»¡ï¼');
                return;
            }

            // ç§»åŠ¨ç‰©å“
            player.inventory[inventoryIdx] = item;
            player.stash[stashIdx] = null;

            // åˆ·æ–°UI
            renderInventory();
            renderStash();
            showNotification(`å·²ä»ä»“åº“å–å‡º ${item.displayName || item.name}`);
        }

        function dropLoot(monster) {
            // æˆå°±è¿½è¸ªï¼šå‡»æ€æ²‰æ²¦é­”
            trackAchievement('kill_monster', { monsterName: monster.name });

            // æˆå°±è¿½è¸ªï¼šå‡»æ€BOSS
            if (monster.isBoss || monster.isQuestTarget) {
                trackAchievement('kill_boss', { isBoss: monster.isBoss, isQuestTarget: monster.isQuestTarget });
            }

            const x = monster.x;
            const y = monster.y;
            const f = player.floor;

            // åŸºç¡€é‡‘å¸æ‰è½
            let goldAmount = Math.floor(Math.random() * 50) + 10;
            if (monster.isBoss || monster.isQuestTarget) {
                goldAmount *= 3; // BOSSæ‰è½3å€é‡‘å¸
            } else if (monster.rarity > 0) {
                goldAmount *= 1.5; // ç²¾è‹±æ€ªæ‰è½1.5å€é‡‘å¸
            }
            groundItems.push({
                type: 'gold',
                val: goldAmount,
                x: x + Math.random() * 20 - 10,
                y: y + Math.random() * 20 - 10,
                rarity: 0,
                name: goldAmount + " é‡‘å¸",
                icon: 'ğŸ’°'
            });

            // ç‰©å“æ‰è½
            let dropChance = 0.4; // åŸºç¡€æ‰è½æ¦‚ç‡
            let dropCount = 1; // åŸºç¡€æ‰è½æ•°é‡

            if (monster.isBoss || monster.isQuestTarget) {
                dropChance = 1.0; // BOSSå¿…å®šæ‰è½
                dropCount = 2 + Math.floor(f / 3); // BOSSè‡³å°‘æ‰è½2ä»¶ï¼Œæ¯3å±‚åŠ 1ä»¶
            } else if (monster.rarity > 0) {
                dropChance = 0.7; // ç²¾è‹±æ€ªé«˜æ¦‚ç‡æ‰è½
            }

            for (let i = 0; i < dropCount; i++) {
                if (Math.random() < dropChance) {
                    const item = createItem(null, f);

                    // BOSSæ‰è½æ›´é«˜å“è´¨
                    if (monster.isBoss || monster.isQuestTarget) {
                        // é‡æ–°rollä¸€æ¬¡ç¨€æœ‰åº¦ï¼Œæé«˜ç¨€æœ‰åº¦æ¦‚ç‡
                        const qualityRoll = Math.random();
                        if (qualityRoll < 0.4) item.rarity = 3; // 40%æ¦‚ç‡ç¨€æœ‰
                        else if (qualityRoll < 0.7) item.rarity = 2; // 30%æ¦‚ç‡é­”æ³•
                    }

                    item.x = x + Math.random() * 30 - 15 + i * 20; // åˆ†æ•£æ‰è½ä½ç½®
                    item.y = y + Math.random() * 30 - 15;
                    groundItems.push(item);
                }
            }

            updateWorldLabels();
        }

        function updateWorldLabels() {
            const c = document.getElementById('world-labels'); c.innerHTML = '';
            groundItems.forEach(i => {
                const d = document.createElement('div'); d.className = 'drop-label'; d.innerText = i.displayName || i.name; d.style.color = getItemColor(i.rarity);
                d.onclick = e => { e.stopPropagation(); if (Math.hypot(i.x - player.x, i.y - player.y) < 100) { if (i.type === 'gold') { player.gold += i.val; createDamageNumber(player.x, player.y - 40, "+" + i.val + "G", 'gold'); AudioSys.play('gold'); } else { if (!addItemToInventory(i)) { showNotification("èƒŒåŒ…å·²æ»¡ï¼"); return; } } groundItems = groundItems.filter(x => x !== i); d.remove(); } };
                i.el = d; c.appendChild(d);
            });
        }

        function getItemColor(r) { return r === 0 ? COLORS.white : r === 1 ? COLORS.white : r === 2 ? COLORS.blue : r === 3 ? COLORS.yellow : COLORS.gold; }
        function isWall(x, y) { const c = Math.floor(x / TILE_SIZE), r = Math.floor(y / TILE_SIZE); return c < 0 || r < 0 || c >= MAP_WIDTH || r >= MAP_HEIGHT || mapData[r][c] === 0; }

        function getEnemyAtCursor() {
            for (let e of enemies) { if (e.dead) continue; if (Math.hypot(e.x - mouse.worldX, e.y - mouse.worldY) < e.radius + 10) return e; }
            return null;
        }
        function getNPCAtCursor() {
            for (let n of npcs) if (Math.hypot(n.x - mouse.worldX, n.y - mouse.worldY) < n.radius + 10) return n;
            return null;
        }

        function performAttack(t) {
            if (player.attackCooldown > 0) return;
            let dmg = Math.floor(Math.random() * (player.damage[1] - player.damage[0] + 1)) + player.damage[0];
            if (Math.random() < player.dex * 0.01) { dmg *= 2; createDamageNumber(t.x, t.y - 40, "æš´å‡»!", '#ffff00'); }
            takeDamage(t, dmg); AudioSys.play('attack');
            if (player.lifeSteal > 0) { let h = Math.ceil(dmg * player.lifeSteal / 100); if (h > 0) { player.hp = Math.min(player.maxHp, player.hp + h); createDamageNumber(player.x, player.y - 40, "+" + h, COLORS.green); } }
            createParticle(t.x, t.y, '#fff', 5);
            player.attackCooldown = 0.5 / (1 + player.attackSpeed / 100);
        }

        function castSkill(type) {
            if (player.floor === 0) return;

            // æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†æœªå­¦ä¹ çš„æŠ€èƒ½
            if (!player.skills[type] || player.skills[type] <= 0) {
                const typeNames = { fireball: 'ç«çƒæœ¯', frostnova: 'éœœä¹‹æ–°æ˜Ÿ', multishot: 'å¤šé‡å°„å‡»' };
                showNotification(`æŠ€èƒ½æœªå­¦ä¹ ï¼š${typeNames[type] || type}`);
                return;
            }

            if (type === 'fireball') {
                if (player.mp < 5) {
                    showNotification('æ³•åŠ›ä¸è¶³ï¼(éœ€è¦ 5 æ³•åŠ›)');
                    return;
                }
                if (player.skillCooldowns.fireball > 0) return;
                player.mp -= 5; player.skillCooldowns.fireball = 0.5;
                const angle = Math.atan2(mouse.worldY - player.y, mouse.worldX - player.x);
                projectiles.push({ x: player.x, y: player.y, angle, speed: 450, life: 0.9, damage: 10 * player.skills.fireball + player.ene, owner: player });
                AudioSys.play('attack');
            } else if (type === 'frostnova') {
                if (player.mp < 15) {
                    showNotification('æ³•åŠ›ä¸è¶³ï¼(éœ€è¦ 15 æ³•åŠ›)');
                    return;
                }
                if (player.skillCooldowns.frostnova > 0) return;
                player.mp -= 15; player.skillCooldowns.frostnova = 4;
                for (let i = 0; i < 360; i += 15) projectiles.push({ x: player.x, y: player.y, angle: i * Math.PI / 180, speed: 300, life: 0.4, damage: 5 * player.skills.frostnova, color: COLORS.ice, freeze: 2, owner: player });
                AudioSys.play('fireball');
            } else if (type === 'multishot') {
                if (player.mp < 10) {
                    showNotification('æ³•åŠ›ä¸è¶³ï¼(éœ€è¦ 10 æ³•åŠ›)');
                    return;
                }
                if (player.skillCooldowns.multishot > 0) return;
                player.mp -= 10; player.skillCooldowns.multishot = 1;
                const base = Math.atan2(mouse.worldY - player.y, mouse.worldX - player.x);
                const cnt = 2 + player.skills.multishot;
                for (let i = 0; i < cnt; i++) {
                    const a = base - 0.3 + (0.6 / (cnt - 1)) * i;
                    projectiles.push({ x: player.x, y: player.y, angle: a, speed: 500, life: 1, damage: player.damage[0] * 0.8, color: '#ffff00', owner: player });
                }
                AudioSys.play('attack');
            }
        }

        function spawnBoss(x, y) { enemies.push({ x, y, hp: 500, maxHp: 500, dmg: 20, speed: 100, isBoss: true, radius: 30, dead: false, cooldown: 0, xpValue: 5000, name: "å± å¤«" }); }

        function renderInventory() {
            const c = document.getElementById('bag-grid'); c.innerHTML = '';
            player.inventory.forEach((i, idx) => {
                const s = document.createElement('div'); s.className = 'bag-slot';
                if (i) {
                    s.innerText = i.icon || ITEM_TYPES[i.type.toUpperCase()].icon; s.style.color = getItemColor(i.rarity); s.style.display = 'flex'; s.style.justifyContent = 'center'; s.style.alignItems = 'center'; s.style.fontSize = '24px';
                    if (i.quantity && i.quantity > 1) {
                        s.innerHTML += `<span class="item-count">${i.quantity}</span>`;
                    }
                    s.onclick = (e) => {
                        e.stopPropagation();
                        // å¦‚æœä»“åº“é¢æ¿æ‰“å¼€ï¼Œç‚¹å‡»ç‰©å“å­˜å…¥ä»“åº“
                        const stashPanel = document.getElementById('stash-panel');
                        if (stashPanel.style.display === 'block') {
                            moveItemToStash(idx);
                        } else {
                            useOrEquipItem(idx);
                        }
                    }
                    s.oncontextmenu = (e) => { e.preventDefault(); e.stopPropagation(); dropItemFromInventory(idx); }
                    s.onmouseenter = (e) => showTooltip(i, e); s.onmouseleave = hideTooltip;
                    s.onmousedown = (e) => e.stopPropagation();
                }
                c.appendChild(s);
            });
            ['mainhand', 'offhand', 'body', 'ring'].forEach(sn => {
                const el = document.getElementById('slot-' + sn), i = player.equipment[sn];
                el.innerHTML = `<span style="color:#333;font-size:10px;position:absolute;bottom:2px;">${sn}</span>`;
                if (i) {
                    const ic = document.createElement('div'); ic.innerText = i.icon || ITEM_TYPES[i.type.toUpperCase()].icon; ic.style.fontSize = '30px'; ic.style.color = getItemColor(i.rarity);
                    el.appendChild(ic); el.onmouseenter = (e) => showTooltip(i, e); el.onmouseleave = hideTooltip;
                    el.onmousedown = (e) => e.stopPropagation();
                } else { el.onmouseenter = null; el.onmouseleave = null; }
            });
            // Additional slots
            ['helm', 'gloves', 'boots', 'belt', 'amulet'].forEach(sn => {
                const el = document.getElementById('slot-' + sn);
                if (!el) return;
                const i = player.equipment[sn];
                el.innerHTML = `<span style="color:#333;font-size:8px;position:absolute;bottom:2px;">${sn.substring(0, 3)}</span>`;
                if (i) {
                    const ic = document.createElement('div'); ic.innerText = i.icon; ic.style.fontSize = '24px'; ic.style.color = getItemColor(i.rarity);
                    el.appendChild(ic); el.onmouseenter = (e) => showTooltip(i, e); el.onmouseleave = hideTooltip;
                    el.onmousedown = (e) => e.stopPropagation();
                } else { el.onmouseenter = null; el.onmouseleave = null; }
            });

            document.getElementById('gold-display').innerText = player.gold;
        }

        function useOrEquipItem(idx) {
            const item = player.inventory[idx]; if (!item) return;

            const shop = document.getElementById('shop-panel');
            if (shop.style.display === 'block') {
                let val = 50;
                if (item.rarity > 1) val *= item.rarity * 2;
                player.gold += val;

                if (item.stackable && item.quantity > 1) {
                    item.quantity--;
                } else {
                    player.inventory[idx] = null;
                }

                createDamageNumber(player.x, player.y - 40, `+${val} G`, 'gold');
                AudioSys.play('gold');
                renderInventory();
                updateBeltUI();
                return;
            }

            if (item.type === 'potion') {
                if (item.heal) player.hp = Math.min(player.maxHp, player.hp + item.heal);
                if (item.mana) player.mp = Math.min(player.maxMp, player.mp + item.mana);
                AudioSys.play('potion'); // æ’­æ”¾å–è¯éŸ³æ•ˆ

                if (item.quantity > 1) {
                    item.quantity--;
                } else {
                    player.inventory[idx] = null;
                }
            }
            else if (item.type === 'scroll') {
                if (player.floor !== 0) {
                    // éªŒè¯å¹¶ä¿®æ­£ä¼ é€é—¨ä½ç½®ï¼Œç¡®ä¿åœ¨ç½—æ ¼è¥åœ°çš„å®‰å…¨åŒºåŸŸ
                    const safePortalPos = validateAndFixPortalPosition(player.x, player.y);
                    townPortal = { returnFloor: player.floor, x: safePortalPos.x, y: safePortalPos.y, activeFloor: 0 };
                    enterFloor(0);
                    if (item.quantity > 1) item.quantity--; else player.inventory[idx] = null;
                } else {
                    showNotification("ä½ å·²ç»åœ¨è¥åœ°äº†");
                }
            }
            else {
                let s = null;
                if (item.type === 'weapon') s = 'mainhand'; if (item.type === 'armor') s = 'body'; if (item.type === 'ring') s = 'ring';
                if (item.type === 'helm') s = 'helm'; if (item.type === 'gloves') s = 'gloves'; if (item.type === 'boots') s = 'boots';
                if (item.type === 'belt') s = 'belt'; if (item.type === 'amulet') s = 'amulet';

                if (s) { const cur = player.equipment[s]; player.equipment[s] = item; player.inventory[idx] = cur; updateStats(); }
            }
            renderInventory(); updateStatsUI(); updateBeltUI();
        }

        function useQuickItem(type) {
            let targetName = "";
            if (type === 'health') targetName = 'æ²»ç–—è¯å‰‚';
            if (type === 'mana') targetName = 'æ³•åŠ›è¯å‰‚';
            if (type === 'scroll') targetName = 'å›åŸå·è½´';

            const idx = player.inventory.findIndex(i => i && i.name === targetName);
            if (idx !== -1) {
                useOrEquipItem(idx);
            } else {
                showNotification("æ²¡æœ‰è¯¥ç‰©å“!");
            }
        }

        function updateBeltUI() {
            const countItem = (name) => {
                const item = player.inventory.find(i => i && i.name === name);
                return item ? (item.quantity || 1) : 0;
            };
            document.getElementById('count-health').innerText = countItem('æ²»ç–—è¯å‰‚');
            document.getElementById('count-mana').innerText = countItem('æ³•åŠ›è¯å‰‚');
            document.getElementById('count-scroll').innerText = countItem('å›åŸå·è½´');
        }

        function gambleItem(type) {
            let cost = 500;
            if (type === 'ring') cost = 800; if (type === 'armor') cost = 400;
            if (player.gold >= cost) {
                player.gold -= cost;
                let rarity = 2;
                if (Math.random() < 0.3) rarity = 3; if (Math.random() < 0.05) rarity = 4;

                let baseName = type === 'weapon' ? 'çŸ­å‰‘' : (type === 'armor' ? 'å¸ƒç”²' : 'é“œæˆ’æŒ‡');
                if (type === 'weapon' && Math.random() > 0.5) baseName = 'å·¨æ–§';
                if (type === 'armor' && Math.random() > 0.5) baseName = 'çš®ç”²';
                if (type === 'helm') baseName = 'çš®å¸½'; if (type === 'gloves') baseName = 'çš®æ‰‹å¥—';
                if (type === 'boots') baseName = 'çš®é´'; if (type === 'belt') baseName = 'è½»æ‰£å¸¦'; if (type === 'amulet') baseName = 'æŠ¤èº«ç¬¦';

                let item = createItem(baseName, player.lvl);
                item.rarity = rarity;
                if (rarity >= 2) {
                    const p = AFFIXES.prefixes[Math.floor(Math.random() * AFFIXES.prefixes.length)];
                    item.displayName = p.name + " " + item.name; item.stats[p.stat] = Math.floor(Math.random() * (p.max - p.min)) + p.min;
                }
                if (rarity >= 3) {
                    const s = AFFIXES.suffixes[Math.floor(Math.random() * AFFIXES.suffixes.length)];
                    item.displayName += s.name; item.stats[s.stat] = (item.stats[s.stat] || 0) + Math.floor(Math.random() * (s.max - s.min)) + s.min;
                }
                if (rarity === 4) { item.displayName = "æš—é‡‘Â·" + item.name; item.stats = { allSkills: 1, str: 10, lifeSteal: 5 }; }

                if (!addItemToInventory(item)) {
                    player.gold += cost;
                    alert("èƒŒåŒ…å·²æ»¡");
                } else {
                    AudioSys.play('gold');
                }
            } else {
                showNotification("é‡‘å¸ä¸è¶³");
            }
        }

        function buyItem(type) {
            let cost = 0;
            let itemName = "";
            if (type === 'health') { cost = 50; itemName = 'æ²»ç–—è¯å‰‚'; }
            else if (type === 'mana') { cost = 50; itemName = 'æ³•åŠ›è¯å‰‚'; }
            else if (type === 'scroll') { cost = 100; itemName = 'å›åŸå·è½´'; }

            if (player.gold >= cost) {
                const item = createItem(itemName, 0);
                if (addItemToInventory(item)) {
                    player.gold -= cost;
                    renderInventory();
                } else {
                    alert("èƒŒåŒ…å·²æ»¡");
                }
            } else {
                showNotification("é‡‘å¸ä¸è¶³");
            }
        }

        function unequipItem(s) {
            const i = player.equipment[s]; if (!i) return;
            if (addItemToInventory(i)) { player.equipment[s] = null; updateStats(); renderInventory(); updateStatsUI(); hideTooltip(); }
        }

        function dropItemFromInventory(idx) {
            const item = player.inventory[idx];
            if (!item) return;

            // æ£€æŸ¥æ˜¯å¦åœ¨ç½—æ ¼è¥åœ°
            if (player.floor === 0) {
                showNotification("åœ¨ç½—æ ¼è¥åœ°ä¸èƒ½ä¸¢å¼ƒç‰©å“");
                return;
            }

            // åˆ›å»ºç‰©å“å‰¯æœ¬å¹¶è®¾ç½®ä½ç½®
            const droppedItem = { ...item };
            droppedItem.x = player.x + Math.random() * 40 - 20;
            droppedItem.y = player.y + Math.random() * 40 - 20;

            // ä»èƒŒåŒ…ç§»é™¤ç‰©å“ï¼ˆå¤„ç†å †å ï¼‰
            if (item.stackable && item.quantity > 1) {
                item.quantity--;
            } else {
                player.inventory[idx] = null;
            }

            // æ·»åŠ åˆ°åœ°é¢
            groundItems.push(droppedItem);
            updateWorldLabels();
            renderInventory();
            updateBeltUI();
            showNotification(`ä¸¢å¼ƒäº† ${item.displayName || item.name}`);
        }

        function updateStats() {
            let str = player.str, dex = player.dex, vit = player.vit, ene = player.ene;
            // Fixed: Stats scaling fix (Str 5%, Dex 1 Armor + 0.5% Crit)
            let baseDmg = 2, armor = 0, ls = 0, ias = 0;

            Object.values(player.equipment).forEach(i => {
                if (!i) return;
                if (i.stats) { str += (i.stats.str || 0); vit += (i.stats.vit || 0); dex += (i.stats.dex || 0); ls += (i.stats.lifeSteal || 0); ias += (i.stats.attackSpeed || 0); }
                if (i.minDmg) baseDmg = i.minDmg; if (i.def) armor += i.def;
            });

            // New Formula
            player.damage = [
                Math.floor((baseDmg + Math.floor(str / 5)) * (1 + str * 0.05)),
                Math.floor((baseDmg + 3 + Math.floor(str / 5)) * (1 + str * 0.05))
            ];
            player.maxHp = vit * 5;
            player.maxMp = ene * 3;
            player.armor = armor + dex; // 1 Dex = 1 Armor
            player.lifeSteal = ls;
            player.attackSpeed = ias;
            player.critChance = Math.min(100, 5 + dex * 0.5); // 5% Base + 0.5% per Dex

            // æ£€æŸ¥æš—é‡‘è£…å¤‡æˆå°±
            checkAllUniqueEquipment();
        }

        function updateUI() {
            document.getElementById('hp-fill').style.height = Math.max(0, Math.min(100, player.hp / player.maxHp * 100)) + '%';
            document.getElementById('hp-text').innerText = Math.floor(player.hp);
            document.getElementById('mp-fill').style.height = Math.max(0, Math.min(100, player.mp / player.maxMp * 100)) + '%';
            document.getElementById('mp-text').innerText = Math.floor(player.mp);

            let xpPct = 0;
            if (player.xpNext > 0) {
                xpPct = (player.xp / player.xpNext * 100);
            }
            document.getElementById('xp-fill').style.width = Math.min(100, xpPct) + '%';
            document.getElementById('hud-lvl').innerText = player.lvl;

            updateLabelsPosition();

            document.querySelectorAll('.skill-btn').forEach(b => b.classList.remove('active'));
            if (player.activeSkill === 'attack') document.getElementById('skill-attack').classList.add('active');
            else {
                const btns = document.querySelectorAll('.skill-btn');
                if (player.activeSkill === 'fireball') btns[1].classList.add('active');
                if (player.activeSkill === 'frostnova') btns[2].classList.add('active');
                if (player.activeSkill === 'multishot') btns[3].classList.add('active');
            }

            const promptEl = document.getElementById('interaction-msg');
            if (interactionTarget) {
                promptEl.style.display = 'block';
                promptEl.innerHTML = `æŒ‰ [Enter] ${interactionTarget.label}`;
            } else {
                promptEl.style.display = 'none';
            }
        }

        function updateStatsUI() {
            document.getElementById('stat-lvl').innerText = player.lvl; document.getElementById('stat-xp').innerText = `${Math.floor(player.xp)}/${Math.floor(player.xpNext)}`;
            document.getElementById('stat-points').innerText = player.points;
            document.getElementById('stat-str').innerText = player.str; document.getElementById('stat-dex').innerText = player.dex;
            document.getElementById('stat-vit').innerText = player.vit; document.getElementById('stat-ene').innerText = player.ene;

            document.getElementById('stat-hp-val').innerText = Math.floor(player.maxHp);
            document.getElementById('stat-mp-val').innerText = Math.floor(player.maxMp);

            document.getElementById('stat-dmg').innerText = `${player.damage[0]}-${player.damage[1]}`;
            document.getElementById('stat-def').innerText = player.armor;
            document.getElementById('stat-crit').innerText = player.critChance.toFixed(1) + '%';
            document.getElementById('stat-ias').innerText = player.attackSpeed + '%'; document.getElementById('stat-ll').innerText = player.lifeSteal + '%';
        }

        function updateSkillsUI() {
            document.getElementById('skill-points').innerText = player.skillPoints;
            document.getElementById('lvl-fireball').innerText = player.skills.fireball;
            document.getElementById('lvl-frostnova').innerText = player.skills.frostnova;
            document.getElementById('lvl-multishot').innerText = player.skills.multishot;
            document.getElementById('bar-lvl-fireball').innerText = player.skills.fireball;
            document.getElementById('bar-lvl-frostnova').innerText = player.skills.frostnova;
            document.getElementById('bar-lvl-multishot').innerText = player.skills.multishot;
        }

        function checkLevelUp() {
            while (player.xp >= player.xpNext) {
                player.lvl++;

                // æˆå°±è¿½è¸ªï¼šè¾¾åˆ°ç­‰çº§
                trackAchievement('reach_level', { level: player.lvl });

                player.xp -= player.xpNext;
                player.xpNext = Math.floor(player.xpNext * 1.5);
                player.points += 5;
                player.skillPoints += 1;
                player.maxHp += 10;
                player.maxMp += 5;
                player.hp = player.maxHp;
                player.mp = player.maxMp;

                createDamageNumber(player.x, player.y - 70, "å‡çº§äº†!", '#daa520');
                AudioSys.play('levelup');
            }
            updateStatsUI(); updateSkillsUI(); updateMenuIndicators();
            SaveSystem.save();
        }

        function togglePanel(id) { const e = document.getElementById(id + '-panel'); e.style.display = e.style.display === 'block' ? 'none' : 'block'; if (e.style.display === 'block') { if (id === 'inventory') renderInventory(); if (id === 'skills') updateSkillsUI(); if (id === 'stats') updateStatsUI(); if (id === 'quest') updateQuestUI(); if (id === 'achievements') renderAchievements(); } }
        function selectSkill(k) { player.activeSkill = k; updateUI(); }
        function addStat(t) { if (player.points > 0) { player[t]++; player.points--; updateStats(); updateStatsUI(); updateMenuIndicators(); } }
        function upgradeSkill(t) { if (player.skillPoints > 0) { player.skills[t]++; player.skillPoints--; updateSkillsUI(); updateMenuIndicators(); } }

        function isHoveringUI() {
            if (mouse.y > window.innerHeight - 140) return true;
            const panels = ['stats-panel', 'inventory-panel', 'skills-panel', 'shop-panel', 'menu-btns', 'quest-panel', 'achievements-panel', 'dialog-box'];
            for (let id of panels) {
                const el = document.getElementById(id);
                if (el && (el.style.display === 'block' || id === 'menu-btns')) {
                    const r = el.getBoundingClientRect();
                    if (mouse.x >= r.left && mouse.x <= r.right && mouse.y >= r.top && mouse.y <= r.bottom) return true;
                }
            }
            return false;
        }

        function showTooltip(item, e) {
            const tt = document.getElementById('tooltip'); tt.style.display = 'block'; tt.style.left = (e.clientX + 15) + 'px'; tt.style.top = (e.clientY + 15) + 'px';
            let html = `<div class="tooltip-title" style="color:${getItemColor(item.rarity)}">${item.displayName || item.name}</div><div class="tooltip-type">${item.type}</div>`;
            if (item.quantity > 1) html += `<div class="tooltip-stat">æ•°é‡: ${item.quantity}</div>`;
            if (item.minDmg) html += `<div class="tooltip-stat">ä¼¤å®³: ${item.minDmg}-${item.maxDmg}</div>`;
            if (item.def) html += `<div class="tooltip-stat">é˜²å¾¡: ${item.def}</div>`;
            if (item.heal) html += `<div class="tooltip-stat" style="color:#d00">æ¢å¤: ${item.heal}</div>`;
            if (item.stats) {
                for (let [k, v] of Object.entries(item.stats)) {
                    let label = k;
                    if (k === 'str') label = "åŠ›é‡"; if (k === 'dex') label = "æ•æ·"; if (k === 'vit') label = "ä½“åŠ›"; if (k === 'lifeSteal') label = "%å¸è¡€"; if (k === 'attackSpeed') label = "%æ”»é€Ÿ"; if (k === 'dmgPct') label = "%ä¼¤å®³"; if (k === 'allSkills') label = "æ‰€æœ‰æŠ€èƒ½";
                    html += `<div class="tooltip-stat" style="color:#4850b8">+${v} ${label}</div>`;
                }
            }
            tt.innerHTML = html;
        }
        function hideTooltip() { document.getElementById('tooltip').style.display = 'none'; }

        // Input
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', e => {
            // ä»»ä½•é¼ æ ‡äº¤äº’æ—¶å°è¯•è‡ªåŠ¨å¯åŠ¨BGM
            AudioSys.tryAutoStartBGM();
            if (e.button === 0) mouse.leftDown = true;
            if (e.button === 2) { mouse.rightDown = true; castSkill(player.activeSkill); }
        });
        window.addEventListener('mouseup', e => { if (e.button === 0) mouse.leftDown = false; });
        window.addEventListener('contextmenu', e => e.preventDefault());
        window.addEventListener('keydown', e => {
            // ä»»ä½•é”®ç›˜äº¤äº’æ—¶å°è¯•è‡ªåŠ¨å¯åŠ¨BGM
            AudioSys.tryAutoStartBGM();
            if (e.key === 'c' || e.key === 'C') togglePanel('stats');
            if (e.key === 'i' || e.key === 'I' || e.key === 'b' || e.key === 'B') togglePanel('inventory');
            if (e.key === 't' || e.key === 'T') togglePanel('skills');
            if (e.key === 'q' || e.key === 'Q') selectSkill('fireball');
            if (e.key === 'w' || e.key === 'W') selectSkill('frostnova');
            if (e.key === 'e' || e.key === 'E') selectSkill('multishot');
            if (e.key === 'j' || e.key === 'J') togglePanel('quest');
            if (e.key === 'a' || e.key === 'A') togglePanel('achievements');

            if (e.key === '1') useQuickItem('health');
            if (e.key === '2') useQuickItem('mana');
            if (e.key === '3') useQuickItem('scroll');

            if (e.key === 'Enter') {
                if (interactionTarget) {
                    if (interactionTarget.type === 'next') enterFloor(player.floor + 1, 'start');
                    else if (interactionTarget.type === 'prev') enterFloor(player.floor - 1, 'end');
                    else if (interactionTarget.type === 'portal') {
                        if (player.floor === 0) {
                            // ä»ç½—æ ¼è¥åœ°è¿”å›åœ°ç‰¢æ—¶ï¼ŒéªŒè¯ä¼ é€é—¨ä½ç½®
                            if (townPortal) {
                                const safeDungeonPos = validateAndFixDungeonPortalPosition(townPortal.x, townPortal.y);
                                townPortal.x = safeDungeonPos.x;
                                townPortal.y = safeDungeonPos.y;
                            }
                            enterFloor(townPortal.returnFloor, 'portal');
                        }
                        else enterFloor(0, 'portal');
                    }
                } else {
                    showNotification("é™„è¿‘æ²¡æœ‰å¯äº’åŠ¨çš„ç›®æ ‡");
                }
            }
        });

        // Prevent move on UI clicks
        document.querySelectorAll('.sys-btn, .skill-btn, .stat-btn, .gamble-slot, .equip-slot, .bag-slot, .panel, .belt-slot').forEach(el => {
            el.onmousedown = (e) => e.stopPropagation();
        });

        // --- Dragging Logic ---
        function initDragging() {
            let dragObj = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            document.querySelectorAll('.panel-header').forEach(header => {
                header.onmousedown = function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    dragObj = header.parentElement;

                    document.querySelectorAll('.panel').forEach(p => p.style.zIndex = 60);
                    dragObj.style.zIndex = 61;

                    const rect = dragObj.getBoundingClientRect();
                    dragObj.style.left = rect.left + 'px';
                    dragObj.style.top = rect.top + 'px';
                    dragObj.style.transform = 'none';

                    dragOffsetX = e.clientX - rect.left;
                    dragOffsetY = e.clientY - rect.top;
                };
            });

            document.addEventListener('mousemove', function (e) {
                if (dragObj) {
                    e.preventDefault();
                    dragObj.style.left = (e.clientX - dragOffsetX) + 'px';
                    dragObj.style.top = (e.clientY - dragOffsetY) + 'px';
                }
            });

            document.addEventListener('mouseup', function () {
                dragObj = null;
            });
        }

        function updateMenuIndicators() {
            document.getElementById('badge-stats').style.display = player.points > 0 ? 'block' : 'none';
            document.getElementById('badge-skills').style.display = player.skillPoints > 0 ? 'block' : 'none';
            document.getElementById('badge-quest').style.display = player.questState === 2 ? 'block' : 'none';
        }

        // ä¿®å¤ï¼šæ¢å¤æ™ºèƒ½å¯¹æ¯” Tooltip
        function showTooltip(item, e) {
            const tt = document.getElementById('tooltip');
            tt.style.display = 'block';

            // è¾¹ç¼˜æ£€æµ‹é˜²æ­¢æº¢å‡ºå±å¹•
            let left = e.clientX + 15;
            let top = e.clientY + 15;
            if (left + 250 > window.innerWidth) left = e.clientX - 265;
            if (top + 200 > window.innerHeight) top = e.clientY - 200;

            tt.style.left = left + 'px';
            tt.style.top = top + 'px';

            // æŸ¥æ‰¾èº«ä¸Šå¯¹åº”éƒ¨ä½çš„è£…å¤‡
            let slot = null;
            // ç®€å•çš„ç±»å‹æ˜ å°„ï¼Œä¸ useOrEquipItem é€»è¾‘ä¸€è‡´
            if (item.type === 'weapon') slot = 'mainhand';
            else if (item.type === 'armor') slot = 'body';
            else if (item.type === 'ring') slot = 'ring';
            else if (item.type === 'helm') slot = 'helm';
            else if (item.type === 'gloves') slot = 'gloves';
            else if (item.type === 'boots') slot = 'boots';
            else if (item.type === 'belt') slot = 'belt';
            else if (item.type === 'amulet') slot = 'amulet';

            const equipped = slot ? player.equipment[slot] : null;
            // åªæœ‰å½“ç‰©å“åœ¨èƒŒåŒ…æˆ–å•†åº—ï¼Œä¸”èº«ä¸Šæœ‰è£…å¤‡æ—¶æ‰æ˜¾ç¤ºå¯¹æ¯”ï¼Œé¿å…æ‚¬åœèº«ä¸Šè£…å¤‡æ—¶è‡ªå·±æ¯”è‡ªå·±
            const isComparing = equipped && item !== equipped;

            const diffSpan = (val, eqVal) => {
                if (!isComparing || eqVal === undefined) return "";
                const diff = val - eqVal;
                if (diff > 0) return ` <span style="color:#00ff00; font-size:0.9em;">(+${diff})</span>`;
                if (diff < 0) return ` <span style="color:#ff4444; font-size:0.9em;">(${diff})</span>`;
                return "";
            };

            let html = `<div class="tooltip-title" style="color:${getItemColor(item.rarity)}">${item.displayName || item.name}</div><div class="tooltip-type">${item.type.toUpperCase()}</div>`;

            if (item.quantity > 1) html += `<div class="tooltip-stat">æ•°é‡: ${item.quantity}</div>`;

            if (item.minDmg) {
                // è®¡ç®—å¹³å‡ä¼¤å®³å·®å¼‚
                let dmgDiff = "";
                if (isComparing && equipped.minDmg) {
                    const avg = (item.minDmg + item.maxDmg) / 2;
                    const eqAvg = (equipped.minDmg + equipped.maxDmg) / 2;
                    const d = Math.floor(avg - eqAvg);
                    if (d > 0) dmgDiff = ` <span style="color:#00ff00; font-size:0.9em;">(å‡ä¼¤ +${d})</span>`;
                    if (d < 0) dmgDiff = ` <span style="color:#ff4444; font-size:0.9em;">(å‡ä¼¤ ${d})</span>`;
                }
                html += `<div class="tooltip-stat">ä¼¤å®³: ${item.minDmg}-${item.maxDmg}${dmgDiff}</div>`;
            }

            if (item.def) html += `<div class="tooltip-stat">é˜²å¾¡: ${item.def}${diffSpan(item.def, equipped ? equipped.def : 0)}</div>`;
            if (item.heal) html += `<div class="tooltip-stat" style="color:#d00">æ¢å¤: ${item.heal}</div>`;

            if (item.stats) {
                for (let [k, v] of Object.entries(item.stats)) {
                    let label = k;
                    if (k === 'str') label = "åŠ›é‡"; if (k === 'dex') label = "æ•æ·"; if (k === 'vit') label = "ä½“åŠ›"; if (k === 'lifeSteal') label = "%å¸è¡€"; if (k === 'attackSpeed') label = "%æ”»é€Ÿ"; if (k === 'dmgPct') label = "%ä¼¤å®³"; if (k === 'allSkills') label = "æ‰€æœ‰æŠ€èƒ½";

                    // å¯¹æ¯”å±æ€§
                    let eqStat = 0;
                    if (equipped && equipped.stats && equipped.stats[k]) eqStat = equipped.stats[k];

                    html += `<div class="tooltip-stat" style="color:#4850b8">+${v} ${label}${diffSpan(v, eqStat)}</div>`;
                }
            }

            // å¦‚æœæ˜¯å¯¹æ¯”çŠ¶æ€ï¼Œæ˜¾ç¤ºæç¤º
            if (isComparing) {
                html += `<div style="margin-top:5px; border-top:1px solid #444; padding-top:2px; color:#666; font-size:10px;">æ­£åœ¨ä¸å·²è£…å¤‡ç‰©å“å¯¹æ¯”</div>`;
            }

            tt.innerHTML = html;
        }

        function hideTooltip() { document.getElementById('tooltip').style.display = 'none'; }

        initDragging();
        init();
    </script>
</body>

</html>